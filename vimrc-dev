" ============================================================================
" ovsoil-vimrc for develop
" Maintainer:
"       ovsoil
"       hxyumail@126.com
"       http://ovsoil.com
" Create Date:
"       01/09/2015
" ============================================================================

" ============================================================================
" Vim-plug initialization
" ============================================================================
let vim_plug_just_installed = 0
let vim_plug_path = expand('~/.vim/autoload/plug.vim')
if !filereadable(vim_plug_path)
    echo "Installing Vim-plug..."
    echo ""
    silent !mkdir -p ~/.vim/autoload
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    let vim_plug_just_installed = 1
endif

" manually load vim-plug the first time
if vim_plug_just_installed
    :execute 'source '.fnameescape(vim_plug_path)
endif

" ============================================================================
" =>Platform
" ============================================================================
let g:system=""
let g:homedir=""
if (has("win32") || has("win95") || has("win64") || has("win16"))
  let g:system="windows"
elseif (has('win32unix'))  " Cygwin
  let g:system="cygwin"
elseif (has("unix"))
  let g:system="unix"
  if ( system('uname') =~ "Darwin")          " ~:去除控制字符
    let g:system="mac"
  endif
endif

if(g:system=="windows")
  set ffs=dos,unix,mac
else
  set ffs=unix,dos,mac
  set encoding=utf8
endif

" ============================================================================
" Active plugins
" ============================================================================
call plug#begin('~/.vim/plugged')

" Plugins from github repos:
" Base
Plug 'arielrossanigo/dir-configs-override.vim'  " Override configs by directory 
Plug 'scrooloose/nerdtree'                      " Better file browser
Plug 'ctrlpvim/ctrlp.vim'               " Code and files fuzzy finder
Plug 'fisadev/vim-ctrlp-cmdpalette'     " Extension to ctrlp, for fuzzy command finder
" Plug 'kien/tabman.vim'                  " Tab list panel
Plug 'Valloric/ListToggle'              " ListToggle: toggle quickfix and location-list
Plug 'IndexedSearch'                    " Search results counter
Plug 'auto_mkdir'                       " auto_mkdir
Plug 'matchit.zip'                      " XML/HTML tags navigation
Plug 'Wombat'                           " Gvim colorscheme
Plug 't9md/vim-choosewin'               " Window chooser
Plug 'fisadev/dragvisuals.vim'          " Drag visual blocks arround
if executable('ack')
  " Plug 'mileszs/ack.vim'              " Ack code search (requires ack)
endif

" Enhancement
Plug 'rosenfeld/conque-term'            " Consoles as buffers
Plug 'fisadev/FixedTaskList.vim'        " Pending tasks list
Plug 'terryma/vim-multiple-cursors'     " Sublime Text style multiple selections for Vim
Plug 'tpope/vim-surround'               " surround
Plug 'Raimondi/delimitMate'             " auto-completion for quotes, parens, brackets
" Plug 'kien/rainbow_parentheses.vim'     " Rainbow parentheses
Plug 'michaeljsmith/vim-indent-object'  " Indent text object
Plug 'jeetsukumaran/vim-indentwise'     " Indentation based movements
" Plug 'ConradIrwin/vim-bracketed-paste'  " automatic set paste
Plug 'easymotion/vim-easymotion'
Plug 'tpope/vim-repeat'

" User Interface
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
" Plug 'edkolev/tmuxline.vim'
" Plug 'edkolev/promptline.vim'
Plug 'flazz/vim-colorschemes'           " all colorschemes of vim.org
Plug 'tomasr/molokai'
Plug 'altercation/vim-colors-solarized'
Plug 'fisadev/fisa-vim-colorscheme'     " Terminal Vim with 256 colors colorscheme

" Develop
Plug 'majutsushi/tagbar'                " Class/module browser
Plug 'scrooloose/syntastic'             " syntastic: syntax check
Plug 'mattn/emmet-vim'                  " Zen coding
" Plug 'motemen/git-vim'                  " Git integration
Plug 'tpope/vim-fugitive'
" Plug 'mhinz/vim-signify'                " Git/mercurial/others diff icons on the side of the file lines
Plug 'airblade/vim-gitgutter'
"
" commenter
Plug 'tpope/vim-commentary'             " comment
Plug 'scrooloose/nerdcommenter'         " Code commenter
Plug 'DoxygenToolkit.vim'               " doxygen
" complete
Plug 'Shougo/neocomplcache.vim'         " Better autocompletion
" if g:system == 'mac' && executable('clang') == 1 && (v:version > 703 || (v:version == 703 && has('patch584')))
"   Plug 'Rip-Rip/clang_complete'
"   Plug 'Valloric/YouCompleteMe'
" endif
" snippets manager (SnipMate), dependencies, and snippets repo
" Plug 'drmingdrmer/xptemplate'         " xptemplate
" Plug 'sirver/ultisnips'               " ultisnips
Plug 'tomtom/tlib_vim'
Plug 'honza/vim-snippets'
Plug 'garbas/vim-snipmate'

" json
Plug 'elzr/vim-json'

" markdown
Plug 'godlygeek/tabular'                " aligning text
Plug 'plasticboy/vim-markdown'

" c/c++
" it's insert mode mappings use <leader>
" Plug 'a.vim'                          " navigate btween head and source file

" python
" python mode (indentation, doc, refactor, lints, code checking, motion and
" operators, highlighting, run and ipdb breakpoints)
Plug 'klen/python-mode'
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'fisadev/vim-isort'              " Automatically sort python imports
Plug 'tmhedberg/SimpylFold'
if has('python')
  Plug 'pignacio/vim-yapf-format'     " YAPF formatter for Python
endif

" javascript
Plug 'pangloss/vim-javascript'
Plug 'kchmck/vim-coffee-script'
" html
Plug 'mattn/emmet-vim'
" css
Plug 'lilydjwg/colorizer'           " Paint css colors with the real color

" ruby on rail
Plug 'tpope/vim-rails'

" erlang
" Plug 'oscarh/vimerl'
Plug 'vim-erlang/vim-erlang-compiler'
Plug 'vim-erlang/vim-erlang-skeletons'
Plug 'vim-erlang/vim-erlang-runtime'
Plug 'vim-erlang/vim-erlang-omnicomplete'
Plug 'vim-erlang/vim-erlang-tags'
Plug 'aerosol/vim-compot'

" lisp
Plug 'kovisoft/slimv'

call plug#end()

" ============================================================================
" Install plugins the first time vim runs
" ============================================================================
if vim_plug_just_installed
    echo "Installing Bundles, please ignore key map error messages"
    :PlugInstall
endif

" General Vim settings and mappings
" ============================================================================
" General
" ============================================================================
set nocompatible                                   " no vi-compatible
filetype plugin indent on                          " allow plugins by file type (required for plugins!)
set wildignore+=*.o,*~,*.so,*.swp,*.zip,*.pyc      " Ignore compiled files
set wildignore+=*_build/*
if(g:system=="windows")
  set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*  " Windows ('noshellslash')
  set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe
else
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*        " Linux/MacOSX
  set wildignore+=*/tmp/*,*.so,*.swp,*.zip
endif
set fileencodings=ucs-bom,utf-8,chinese
set formatoptions+=m                              " 如遇Unicode值大于255的文本，不必等到空格再折行。
set formatoptions+=B                              " 合并两行中文时，不在中间加空格：
set ambiwidth=single
set nrformats=                                    " 无论前面是否加零，都把数字作为十进制处理(在使用<C-x>, <C-a>的时候)
set autoread                                      " Set to auto read when a file is changed from the outside

" backup, swap and undos storage
set noswapfile
set directory=~/.vim/dirs/tmp     " directory to place swap files in
set backup                        " make backup files
" set nobackup                      " default: off
" set nowritebackup                 " default: on
set backupdir=~/.vim/dirs/backups " where to put backup files
set undofile                      " persistent undos - undo after you re-open the file
set undodir=~/.vim/dirs/undos
set viminfo+=n~/.vim/dirs/viminfo
" create needed directories if they don't exist
if !isdirectory(&backupdir)
    call mkdir(&backupdir, "p")
endif
if !isdirectory(&directory)
    call mkdir(&directory, "p")
endif
if !isdirectory(&undodir)
    call mkdir(&undodir, "p")
endif
" Return to last edit position when opening files
autocmd BufReadPost *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal! g`\"" |
      \ endif
set viminfo^=%                  " Remember info about open buffers on close

" ============================================================================
" => User Interface
" ============================================================================
set nu                          " show line numbers
set ruler                       " Always show current position
set scrolloff=7                 " Set 7 lines to the cursor
set hid                         " A buffer becomes hidden when it is abandoned
" status line
set laststatus=2                " always show status line - use 2 lines
set statusline=%<%f\ %h%m%r%=%k[%{(&fenc==\"\")?&enc:&fenc}%{(&bomb?\",BOM\":\"\")}]\ %-14.(%l,%c%V%)\ %P
set scrolloff=7                 " when scrolling, 7 lines away from screen border
" autocompletion of files and commands behaves like shell
" (complete only the common part, list the options that match)
set wildmode=list:longest
" Comment this line to enable autocompletion preview window
" (displays documentation related to the selected completion option)
" Disabled by default because preview makes the window flicker
set completeopt-=preview

syntax on                       " syntax highlight on
set incsearch                   " incremental search
set hlsearch                    " highlighted search results
set backspace=eol,start,indent  " Configure backspace so it acts as it should act
set whichwrap+=<,>,h,l
set ignorecase                  " Ignore case when searching
set smartcase                   " When searching try to be smart about cases
set hlsearch                    " Highlight search results

set lazyredraw                  " Don't redraw while executing macros
set magic                       " For regular expressions turn magic on
set showmatch                   " Show matching brackets
set mat=2                       " tenths of a second to blink when matching brackets

set noerrorbells                " No annoying sound on errors
set novisualbell
set vb t_vb=
set lbr                         " Linebreak on 500 characters
set tm=500
set tw=500

set autoindent                  " Auto indent
set smartindent                 " Smart indent
set cindent                     " C indent
set wrap                        " Wrap lines
set cinoptions=g0

" use 256 colors when possible
if (&term =~? 'mlterm\|xterm\|xterm-256\|screen-256\|gnome-terminal') || has('nvim')
  let &t_Co = 256
  colorscheme molokai
else
  colorscheme delek
endif

" Set extra options when running in GUI mode
if has('gui_running')
  colorscheme wombat
  set guifont=Monaco:h12
  " set guifont=Source_Code_Pro:h13
  set guioptions-=T   " no toobar
  set guioptions-=r   " no right scroolbar
  set guioptions-=L   " no left scrollbar except there is a vertically split windows
  set guitablabel=%M\ %t
  set showtabline=0   " no tabine
  set linespace=2
  set noimd
  set t_Co=256
endif

set smarttab                      " Be smart when using tabs
set expandtab                     " Use spaces instead of tabs
set tabstop=4                     " display spaces number as tab
set softtabstop=4
set shiftwidth=4                  " insert 1 tab == 4 spaces
set list
nmap <leader>l :set list!<cr>
" set listchars=tab:\|\ ,eol:$    " display tab with '|    ', display lineend 
set listchars=tab:\|\             " display tab with '|    '
highlight BadWhitespace ctermbg=Red guibg=DarkRed
au BufNewFile,BufRead *.py,*.pyw,*.c,*.h,*.coffee match BadWhitespace /\s\+$/

" set filetype
au BufNewFile,BufRead *.spacemacs setf lisp
" FileType Specific Changes
if has ( "autocmd" )
  autocmd FileType vim setlocal ts=2 sts=2 sw=2 expandtab
  " autocmd FileType erlang setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType json,html,xhtml,xml,css,htmldjango setlocal ts=2 sts=2 sw=2 expandtab
  " autocmd FileType javascript setlocal ts=2 sts=2 sw=2 expandtab
endif

" set cursorcolumn          "高亮当前列 cuc
" set cursorline            "高亮当前行 cul
" autocmd! InsertEnter * set cul
" autocmd! InsertLeave * set nocul

"设置标记一列的背景颜色和数字一行颜色一致
hi! link SignColumn   LineNr
hi! link ShowMarksHLl DiffAdd
hi! link ShowMarksHLu DiffChange
"" for error highlight，防止错误整行标红导致看不清
highlight clear SpellBad
highlight SpellBad term=standout ctermfg=1 term=underline cterm=underline
highlight clear SpellCap
highlight SpellCap term=underline cterm=underline
highlight clear SpellRare
highlight SpellRare term=underline cterm=underline
highlight clear SpellLocal
highlight SpellLocal term=underline cterm=underline

"auto save folding
"au BufWinLeave *.* silent mkview
"au BufWinLeave *.* silent! loadview
set foldenable                  " enable folding
" set foldcolumn=2                " add a fold column
set foldmethod=syntax           " default
set foldlevel=20                " start out with everything folded

" ============================================================================
" => Mapping
" ============================================================================
let mapleader = "\<Space>"
let g:mapleader = "\<Space>"

function! HasHelp()
  " Save current window number to revert.
  let nwin = 1
  while 1
    let nbuf = winbufnr(nwin)
    " all window processed, there is no help buftype, return 0
    if nbuf == -1
      return 0
    endif
    " if there is help buftype, return 1
    if getbufvar(nbuf, '&buftype') ==# 'help'
      return 1
    else
      let nwin = nwin + 1
    endif
  endwhile
endfunction

function! ToggleHelp()
  if HasHelp()
    :helpclose
  else
    :help
  endif
endfunction

" F1 - help; F2 - file(nerdtree); F3 - tag(tagbar); F4 - tasklist
" save as sudo
ca w!! w !sudo tee "%"

nmap <silent><F1> :call ToggleHelp()<cr>
nmap <leader>th :call ToggleHelp()<cr>

" ---------------------------------------
" files navigation
" ---------------------------------------
" Buffer
nmap <leader>bn :bnext<cr>
nmap <leader>bp :bprevious<cr>
nmap <Leader>b1 :1b<CR>
nmap <Leader>b2 :2b<CR>
nmap <Leader>b3 :3b<CR>
nmap <Leader>b4 :4b<CR>
nmap <Leader>b5 :5b<CR>
nmap <Leader>b6 :6b<CR>
nmap <Leader>b7 :7b<CR>
nmap <Leader>b8 :8b<CR>
nmap <Leader>b9 :9b<CR>
nmap <Leader>b0 :10b<CR>
nmap <leader>bd :bdelete<cr>           " Close the current buffer
nmap <leader>ba :1,1000 bd!<cr>        " Close all the buffers
nmap <leader>b<tab> :b#<cr>            " switch between most recently buffer
" Ngb to jump to buffer number N
let c = 1
while c <= 99
  execute "nnoremap " . c . "gb :" . c . "b\<CR>"
  let c += 1
endwhile
nmap <leader>cd :cd %:p:h<cr>:pwd<cr>       " Switch CWD to the directory of the open buffer
" Specify the behavior when switching between buffers
try
  set switchbuf=useopen,usetab  "newtab
  set stal=2
catch
endtry

" Tab
" No Tab, I rarely use tab

" ---------------------------------------
" windows Moving
" ---------------------------------------
map j gj
map k gk
nmap H ^
nmap L $
map <leader>wj <C-W>j
map <leader>wk <C-W>k
map <leader>wh <C-W>h
map <leader>wl <C-W>l
" nmap <leader>1 :resize -3<cr>
" nmap <leader>2 :resize +3<cr>
" nmap <leader>3 :vertical resize -3<cr>
" nmap <leader>4 :vertical resize +3<cr>
if (g:system=="mac")
  nmap <D-j> <M-j>
  nmap <D-k> <M-k>
  vmap <D-j> <M-j>
  vmap <D-k> <M-k>
endif

" ---------------------------------------
" folding
" ---------------------------------------
nnoremap zO zCzO
nnoremap ,z zMzv

" ---------------------------------------
" Edit
" ---------------------------------------
nmap <leader>pp :setlocal paste!<cr>                " Toggle paste mode on and off
map <leader>= <Esc>:%!python -m json.tool<cr>       " format json
au InsertLeave * set nopaste            " Disbale paste mode when leaving insert mode
" set clipboard=unnamed

" Delete the blank space or Windows ^M at trail of line
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc
nmap <leader>db :call DeleteTrailingWS()<cr>       " Remove blank space in lineend
nmap <leader>dm mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm   " Remove the Windows ^M
autocmd BufWrite *.py :call DeleteTrailingWS()
autocmd BufWrite *.coffee :call DeleteTrailingWS()

" insert some usefull text
imap <silent> <C-D><C-D> <C-R>=strftime("%e %b %Y")<cr>
imap <silent> <C-T><C-T> <C-R>=strftime("%l:%M %p")<cr>
imap <silent> <C-C><C-C> <C-R>=string(eval(input("Calculate: ")))<cr>

" ---------------------------------------
" search, vimgrep
" ---------------------------------------
if executable('ag')             " The Silver Searcher
  set grepprg=ag\ --nogroup\ --nocolor
  let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --ignore .git --ignore .DS_Store --ignore node_modules --ignore "**/*.pyc" --hidden -g ""'
  " ag is fast enough that CtrlP doesn't need to cache
  " let g:ctrlp_use_caching = 0
else
  set grepprg=grep\ -nrI\ --exclude-dir={CVS,'.bzr','.git','.hg','.svn'}
  if(g:system=="windows")
    let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d'  " Windows
  else
    let g:ctrlp_user_command = 'find %s -type f'        " MacOSX/Linux
  endif
endif

nnoremap <leader><cr> :nohl<cr>
" Search for selected text.
" vnoremap // y/<C-R>"<cr>     " use following script instead
" http://vim.wikia.com/wiki/VimTip171
let s:save_cpo = &cpo | set cpo&vim
if !exists('g:VeryLiteral')
  let g:VeryLiteral = 0
endif
function! s:VSetSearch(cmd)
  let old_reg = getreg('"')
  let old_regtype = getregtype('"')
  normal! gvy
  if @@ =~? '^[0-9a-z,_]*$' || @@ =~? '^[0-9a-z ,_]*$' && g:VeryLiteral
    let @/ = @@
  else
    let pat = escape(@@, a:cmd.'\')
    if g:VeryLiteral
      let pat = substitute(pat, '\n', '\\n', 'g')
    else
      let pat = substitute(pat, '^\_s\+', '\\s\\+', '')
      let pat = substitute(pat, '\_s\+$', '\\s\\*', '')
      let pat = substitute(pat, '\_s\+', '\\_s\\+', 'g')
    endif
    let @/ = '\V'.pat
  endif
  normal! gV
  call setreg('"', old_reg, old_regtype)
endfunction
vnoremap <silent> * :<C-U>call <SID>VSetSearch('/')<cr>/<C-R>/<cr>
vnoremap <silent> # :<C-U>call <SID>VSetSearch('?')<cr>?<C-R>/<cr>
vmap <kMultiply> *
nmap <silent> <Plug>VLToggle :let g:VeryLiteral = !g:VeryLiteral
      \\| echo "VeryLiteral " . (g:VeryLiteral ? "On" : "Off")<cr>
if !hasmapto("<Plug>VLToggle")
  nmap <unique> <Leader>vl <Plug>VLToggle
endif
let &cpo = s:save_cpo | unlet s:save_cpo

" highlight but not search the word at cursor
nnoremap <leader>h :let @/='\<<C-R>=expand("<cword>")<cr>\>'<cr>:set hls<cr>
" highlight but not search the selected text
vnoremap <leader>h :<C-U>call <SID>VSetSearch('/')<cr>/<C-R>/<cr>N

" replace selected text
vnoremap <C-r> "hy:%s/<C-r>h//gc<left><left><left>
vnoremap <C-h> ""y:%s/<C-R>=escape(@", '/\')<cr>//g<Left><Left>

" grep the word at cursor in current dir
nnoremap <leader>gr :grep! "\b<C-R><C-W>\b"<cr>:cw<cr>
vnoremap <leader>gr y:grep! '<C-R>"' .<cr>:cw<cr>

" ============================================================================
" => Plugins settings and mappings
" ============================================================================
function! IsLoad(pluginname)
  if &runtimepath =~ a:pluginname
    return 1
  else
    return 0
  endif
endfunction

if IsLoad('nerdtree')
  let mymapping_file = expand('~/.vim/nerdtree_plugin/mymapping.vim')
  if !filereadable(mymapping_file)
    echo "Installing custom mapping for nerdtree ..."
    echo ""
    silent !mkdir -p ~/.vim/nerdtree_plugin
    silent !curl -fLo ~/.vim/nerdtree_plugin/mymapping.vim --create-dirs https://raw.githubusercontent.com/ovsoil/vimrc/master/nerdtree_plugin/mymapping.vim
  endif
  nmap <silent><F2> :NERDTreeToggle<cr><cr>
  let g:NERDTree_title="NERDTree"
  let NERDTreeShowBookmarks=1         "allways show bookmarks
  let NERDTreeChDirMode=2             "auto set pwd when open bookmarks
  let NERDTreeIgnore=['node_modules', 'bower_components', '\.pyc$', '\.pyo$', '\~$', '\.beam$']     "ignore files in NERDTree
  " open a NERDTree automatically when vim starts up if no files were specified
  autocmd StdinReadPre * let s:std_in=1
  autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
  " close vim if the only window left open is a NERDTree
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif
  " open NERDTree automatically when vim starts up on opening a directory
  autocmd StdinReadPre * let s:std_in=1
  autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif
endif

if IsLoad('tagbar')
  nmap <silent><F3> :TagbarToggle<cr>
  let g:tagbar_ctags_bin = 'ctags'
  let g:tagbar_width     = 30
  let g:tagbar_autofocus = 1      " autofocus on tagbar open
  "autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()
endif

if IsLoad('fixedtasklist')
  map <F4> :TaskList<cr>                " show pending tasks list
  map <leader>lt :TaskList<cr>          " show pending tasks list
endif

if IsLoad('ctrlp')
  " file finder mapping
  " let g:ctrlp_map = '<leader>ff'
  " avoid open file in nerdtree window
  nmap <silent> <expr> <Leader>ff (expand('%') =~ 'NERD_tree' ? "\<c-w>\<c-w>" : '').":CtrlP\<cr>"
  nmap <leader>fr :CtrlPMRU<cr>
  nmap <leader>fb :CtrlPBuffer<cr>
  nmap <leader>bb :CtrlPBuffer<cr>
  nmap <leader>ft :CtrlPTag<cr>
  nmap <leader>fe :CtrlP <c-r>=expand("%:p:h")<cr><cr>
  " tags (symbols) in current file finder mapping
  nmap ,g :CtrlPBufTag<cr>
  nmap <leader>st :CtrlPBufTag<cr>
  " tags (symbols) in all files finder mapping
  nmap ,G :CtrlPBufTagAll<cr>
  nmap <leader>sT :CtrlPBufTagAll<cr>
  " general code finder in all files mapping
  nmap ,f :CtrlPLine<cr>
  nmap <leader>sl :CtrlPLine<cr>
  " commands finder mapping
  nmap ,c :CtrlPCmdPalette<cr>
  nmap <leader>sc :CtrlPCmdPalette<cr>
  " to be able to call CtrlP with default search text
  function! CtrlPWithSearchText(search_text, ctrlp_command_end)
      execute ':CtrlP' . a:ctrlp_command_end
      call feedkeys(a:search_text)
  endfunction
  " same as previous mappings, but calling with current word as default text
  nmap ,wg :call CtrlPWithSearchText(expand('<cword>'), 'BufTag')<cr>
  nmap ,wG :call CtrlPWithSearchText(expand('<cword>'), 'BufTagAll')<cr>
  nmap ,wf :call CtrlPWithSearchText(expand('<cword>'), 'Line')<cr>
  nmap ,we :call CtrlPWithSearchText(expand('<cword>'), '')<cr>
  nmap ,pe :call CtrlPWithSearchText(expand('<cfile>'), '')<cr>
  nmap ,wc :call CtrlPWithSearchText(expand('<cword>'), 'CmdPalette')<cr>
  " let g:ctrlp_working_path_mode = 0             " don't change working directory
  let g:ctrlp_working_path_mode = 'ra'        " smart change working directory
  " ignore these files and folders on file finder
  let g:ctrlp_custom_ignore = {
    \ 'dir':  '\v[\/](\.git|\.hg|\.svn|node_modules)$',
    \ 'file': '\.(o|swp|beam|pyc|pyo|wav|mp3|ogg|blend)$\|\.(log|jpg|png|jpeg)$|__init__\.py',
    \ }

endif

if IsLoad('ack')
  " simple recursive grep
  nmap ,r :Ack
  nmap ,wr :Ack <cword><cr>
endif

if IsLoad('molokai')
  let g:molokai_original=1
  let g:rehash256=1
endif

if IsLoad('tabman')
  " mappings to toggle display, and to focus on it
  let g:tabman_toggle = '<leader>mt'
  let g:tabman_focus  = '<leader>mf'
endif

if IsLoad('vim-airline')
  let g:airline_powerline_fonts = 0
  let g:airline_theme = 'bubblegum'
  let g:airline#extensions#whitespace#enabled = 0
  let g:airline#extensions#tabline#enabled = 1
  let g:airline#extensions#tabline#left_sep = ' '
  let g:airline#extensions#tabline#left_alt_sep = '|'
  let g:airline#extensions#bufferline#enabled = 0
  let g:airline#extensions#tabline#buffer_nr_show = 1
  let g:airline#extensions#tabline#buffer_nr_format = '%s:'
  let g:airline#extensions#tabline#fnamecollapse = 1          "collopsing parent dir
  let g:airline#extensions#tabline#fnametruncate = 10         "non-active buffer name specified length
  " to use fancy symbols for airline, uncomment the following lines and use a
  " patched font (more info on the README.rst)
  "if !exists('g:airline_symbols')
  "   let g:airline_symbols = {}
  "endif
  "let g:airline_left_sep = '⮀'
  "let g:airline_left_alt_sep = '⮁'
  "let g:airline_right_sep = '⮂'
  "let g:airline_right_alt_sep = '⮃'
  "let g:airline_symbols.branch = '⭠'
  "let g:airline_symbols.readonly = '⭤'
  "let g:airline_symbols.linenr = '⭡'
endif

if  IsLoad('promptline')
  let g:promptline_preset = 'full'
  let g:promptline_theme = 'airline'
endif

if IsLoad('rainbow_parentheses')
  let g:rbpt_colorpairs = [
        \ ['brown',       'RoyalBlue3'],
        \ ['Darkblue',    'SeaGreen3'],
        \ ['darkgray',    'DarkOrchid3'],
        \ ['darkgreen',   'firebrick3'],
        \ ['darkcyan',    'RoyalBlue3'],
        \ ['darkred',     'SeaGreen3'],
        \ ['darkmagenta', 'DarkOrchid3'],
        \ ['brown',       'firebrick3'],
        \ ['gray',        'RoyalBlue3'],
        \ ['black',       'SeaGreen3'],
        \ ['darkmagenta', 'DarkOrchid3'],
        \ ['Darkblue',    'firebrick3'],
        \ ['darkgreen',   'RoyalBlue3'],
        \ ['darkcyan',    'SeaGreen3'],
        \ ['darkred',     'DarkOrchid3'],
        \ ['red',         'firebrick3'],
        \ ]
  let g:rbpt_max = 16
  let g:rbpt_loadcmd_toggle = 0
  au VimEnter * RainbowParenthesesToggle
  au Syntax * RainbowParenthesesLoadRound
  au Syntax * RainbowParenthesesLoadSquare
  au Syntax * RainbowParenthesesLoadBraces
endif

if IsLoad('delimitmate')
  let delimitMate_quotes = "\" ' `"
  au FileType python,vim let b:delimitMate_quotes = "' `"
  au FileType markdown let b:delimitMate_quotes = "\" '"
  au FileType lisp,clojure let b:delimitMate_quotes = "\" `"

endif

if IsLoad('syntastic')
  " show list of errors and warnings on the current file
  nmap <leader>le :Errors<cr>
  let g:syntastic_always_populate_loc_list = 0
  let g:syntastic_auto_loc_list = 0
  let g:syntastic_check_on_open = 1
  let g:syntastic_check_on_wq = 0
  " don't put icons on the sign column (it hides the vcs status icons of signify)
  let g:syntastic_enable_signs = 0

  " c++11 support
  let g:syntastic_cpp_compiler = 'clang++'
  let g:syntastic_cpp_compiler_options = '-std=c++11 -stdlib=libc++'

  " python support
  " let g:syntastic_python_python_exec = '/path/to/python3'    " if use python3
  " let g:syntastic_python_checkers = ['pylint']
  let g:syntastic_python_checkers= ['flake8']
  let g:syntastic_python_flake8_post_args='--ignore=E501,E128'

  " erlang support
  " let g:syntastic_erlc_include_path = 'ebin'

  " custom icons (enable them if you use a patched font, and enable the previous 
  " setting)
  "let g:syntastic_error_symbol = '✗'
  "let g:syntastic_warning_symbol = '⚠'
  "let g:syntastic_style_error_symbol = '✗'
  "let g:syntastic_style_warning_symbol = '⚠'
 
  " whether to show balloons
  let g:syntastic_enable_balloons = 1
endif

if IsLoad('nerdcommenter')
  " Add spaces after comment delimiters by default
  let g:NERDSpaceDelims = 1
  " Use compact syntax for prettified multi-line comments
  let g:NERDCompactSexyComs = 1
  " Align line-wise comment delimiters flush left instead of following code indentation
  let g:NERDDefaultAlign = 'left'
  " Set a language to use its alternate delimiters by default
  let g:NERDAltDelims_java = 1
  " Add your own custom formats or override the defaults
  let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
  " Allow commenting and inverting empty lines (useful when commenting a region)
  let g:NERDCommentEmptyLines = 1
  " Enable trimming of trailing whitespace when uncommenting
  let g:NERDTrimTrailingWhitespace = 1
endif

if IsLoad('python-mode')
  " don't use linter, we use syntastic for that
  let g:pymode_lint_on_write = 0
  let g:pymode_lint_signs = 0
  " don't fold python code on open
  let g:pymode_folding = 0
  " don't load rope by default. Change to 1 to use rope
  let g:pymode_rope = 0
  " open definitions on same window, and custom mappings for definitions and
  " occurrences
  " Override go-to.definition key shortcut to Ctrl-]
  let g:pymode_rope_goto_definition_bind = "<C-]>"
  " let g:pymode_rope_goto_definition_bind = ',d'
  let g:pymode_rope_goto_definition_cmd = 'e'
  " Override run current python file key shortcut to Ctrl-Shift-e
  let g:pymode_run_bind = "<C-S-e>"
  " Override view python doc key shortcut to Ctrl-Shift-d
  " let g:pymode_doc_bind = "<C-S-d>"
  nmap ,D :tab split<cr>:PymodePython rope.goto()<cr>
  nmap ,o :RopeFindOccurrences<cr>

  let g:pymode_virtualenv = 1
  " let g:pymode_virtualenv_path = $VIRTUAL_ENV
endif

if IsLoad("simpyfold")
  let g:SimpylFold_docstring_preview=1
endif

if IsLoad('neocomplcache')
  " most of them not documented because I'm not sure how they work
  " (docs aren't good, had to do a lot of trial and error to make 
  " it play nice)
  let g:neocomplcache_enable_at_startup = 1
  let g:neocomplcache_enable_ignore_case = 1
  let g:neocomplcache_enable_smart_case = 1
  let g:neocomplcache_enable_auto_select = 1
  let g:neocomplcache_enable_fuzzy_completion = 1
  let g:neocomplcache_enable_camel_case_completion = 1
  let g:neocomplcache_enable_underbar_completion = 1
  let g:neocomplcache_fuzzy_completion_start_length = 1
  let g:neocomplcache_auto_completion_start_length = 1
  let g:neocomplcache_manual_completion_start_length = 1
  let g:neocomplcache_min_keyword_length = 1
  let g:neocomplcache_min_syntax_length = 1
  " complete with workds from any opened file
  let g:neocomplcache_same_filetype_lists = {}
  let g:neocomplcache_same_filetype_lists._ = '_'
endif

if IsLoad('dragvisuals')
  " mappings to move blocks in 4 directions
  vmap <expr> <S-M-LEFT> DVB_Drag('left')
  vmap <expr> <S-M-RIGHT> DVB_Drag('right')
  vmap <expr> <S-M-DOWN> DVB_Drag('down')
  vmap <expr> <S-M-UP> DVB_Drag('up')
  " mapping to duplicate block
  vmap <expr> D DVB_Duplicate()
endif

if IsLoad('signify')
  " this first setting decides in which order try to guess your current vcs
  " UPDATE it to reflect your preferences, it will speed up opening files
  let g:signify_vcs_list = [ 'git', 'hg' ]
  " nicer colors
  highlight DiffAdd           cterm=bold ctermbg=none ctermfg=119
  highlight DiffDelete        cterm=bold ctermbg=none ctermfg=167
  highlight DiffChange        cterm=bold ctermbg=none ctermfg=227
  highlight SignifySignAdd    cterm=bold ctermbg=237  ctermfg=119
  highlight SignifySignDelete cterm=bold ctermbg=237  ctermfg=167
  highlight SignifySignChange cterm=bold ctermbg=237  ctermfg=227
endif

if IsLoad('vim-choosewin')
  " mapping
  nmap  -  <Plug>(choosewin)
  " show big letters
  let g:choosewin_overlay_enable = 1
endif

if IsLoad('clang_complete')
  let g:clang_complete_auto = 1
  let g:clang_complete_copen = 1
  let g:clang_user_options='|| exit 0'
  if(g:system == 'mac')
    let g:clang_use_library = 1
    let g:clang_library_path = "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib"
  elseif(g:system == 'unix')
    let g:clang_use_library = 1
    let g:clang_library_path= "/usr/lib/clang"
  elseif (g:system == 'windows')
    let g:clang_use_library = 0
  elseif(g:system == 'cygwin')
    let g:clang_use_library = 1
    let g:clang_library_path= "/usr/bin"
  endif
endif

if IsLoad('YouCompleteMe')
  let g:ycm_key_list_select_completion = ['<c-n>', '<Down>']
  let g:ycm_key_list_previous_completion = ['<c-p>', '<Up>']
  let g:ycm_confirm_extra_conf = 0
  let g:ycm_autoclose_preview_window_after_completion=1
  map <leader>g  :YcmCompleter GoToDefinitionElseDeclaration<cr>
endif

if IsLoad('ultisnips')
  let g:UltiSnipsUsePythonVersion=2
  let g:UltiSnipsExpandTrigger="<tab>"
  let g:UltiSnipsJumpForwardTrigger="<c-j>"
  let g:UltiSnipsJumpBackwardTrigger="<c-k>"
  " If you want :UltiSnipsEdit to split your window.
  let g:UltiSnipsEditSplit="vertical"
endif

" ===============================================================================
" => ctags
" ===============================================================================
" C++ tags: "!ctags -R --c++-kinds=+px --fields=+iaS --extra=+q ."
" :ts tagselect, :tp 为上一个tag标记文件，:tn 为下一个tag标记文件。
" g+]直接显示ctag结果列表
" 让CTRL-]只有一个选择时自动跳转，多个选择时，出现选择列表
" map <C-]> :tselect <C-R>=expand("<cword>")<cr><cr>
" map <C-]> g<C-]>

"添加特定的（已经生成tags）的函数库的tags
autocmd FileType cpp set tags+=~/.vim/cpp_src/tags

" ===============================================================================
" => cscope
" ===============================================================================
if has("cscope")
  set csprg=cscope
  " Use both cscope and ctag
  set cscopetag
  " Show msg when cscope db added
  set cscopeverbose
  " Use cscope for definition search first
  set cscopetagorder=0
endif

"自动加载cscope.out
" function! LoadCscope()
"     let db = findfile("cscope.out", ".;")    "从当前目录往上找，直到找到 cscope.out 这个命令能到找到cscope.out的路径。
"     if (!empty(db))
"         let path = strpart(db, 0, match(db, "/cscope.out$"))
"         set nocsverb                                "suppress 'duplicate connection' error
"         exe "cs add " . db . " " . path
"         set csverb
"     endif
" endfunction
" autocmd BufRead,BufEnter *.cpp,*.hpp call LoadCscope()

"s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方
"g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能
"d: 查找本函数调用的函数
"c: 查找调用本函数的函数
"t: 查找指定的字符串
"e: 查找egrep模式，相当于egrep功能，但查找速度快多了
"f: 查找并打开文件，类似vim的find功能
"i: 查找包含本文件的文
set cscopequickfix=s-,g-,c-,t-,e-,f-,i-,d-
nmap <C-@>s :cs find s <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>g :cs find g <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>c :cs find c <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>t :cs find t <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>e :cs find e <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>f :cs find f <C-R>=expand("<cfile>")<cr><cr>:copen<cr>
nmap <C-@>i :cs find i ^<C-R>=expand("<cfile>")<cr>$<cr>:copen<cr>
nmap <C-@>d :cs find d <C-R>=expand("<cword>")<cr><cr>:copen<cr>

