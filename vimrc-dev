" ===============================================================================
" vimrc for develop
" Maintainer:
"       ovsoil
"       hxyumail@126.com
"       http://ovsoil.com
" Create Date:
"       01/09/2015
" ===============================================================================

" ===============================================================================
" =>Platform
" ===============================================================================
let g:system=""
let g:homedir=""
if (has("win32") || has("win95") || has("win64") || has("win16"))
  let g:system="windows"
elseif (has('win32unix'))  " Cygwin
  let g:system="cygwin"
elseif (has("unix"))
  let g:system="unix"
  if ( system('uname') =~ "Darwin")          " ~:去除控制字符
    let g:system="mac"
  endif
endif

" copy from windows default _vimrc
if(g:system=="windows")
  source $VIMRUNTIME/vimrc_example.vim
  source $VIMRUNTIME/mswin.vim
  behave mswin
  set diffexpr=MyDiff()
  function MyDiff()
    let opt = '-a --binary '
    if &diffopt =~ 'icase' | let opt = opt . '-i ' | endif
    if &diffopt =~ 'iwhite' | let opt = opt . '-b ' | endif
    let arg1 = v:fname_in
    if arg1 =~ ' ' | let arg1 = '"' . arg1 . '"' | endif
    let arg2 = v:fname_new
    if arg2 =~ ' ' | let arg2 = '"' . arg2 . '"' | endif
    let arg3 = v:fname_out
    if arg3 =~ ' ' | let arg3 = '"' . arg3 . '"' | endif
    if $VIMRUNTIME =~ ' '
      if &sh =~ '\<cmd'
        if empty(&shellxquote)
          let l:shxq_sav = ''
          set shellxquote&
        endif
        let cmd = '"' . $VIMRUNTIME . '\diff"'
      else
        let cmd = substitute($VIMRUNTIME, ' ', '" ', '') . '\diff"'
      endif
    else
      let cmd = $VIMRUNTIME . '\diff'
    endif
    silent execute '!' . cmd . ' ' . opt . arg1 . ' ' . arg2 . ' > ' . arg3
    if exists('l:shxq_sav')
      let &shellxquote=l:shxq_sav
    endif
  endfunction
endif

if(g:system=="windows")
  set ffs=dos,unix,mac
else
  set ffs=unix,dos,mac
  set encoding=utf8
endif

" ===============================================================================
" => 插件管理和更新 Vundle
" ===============================================================================
set nocompatible                    " be iMproved, vundle required
filetype off                        " vundle required
if (g:system=="windows")
  set rtp+=$VIM/vimfiles/bundle/Vundle.vim   " set the runtime path to include Vundle and initialize
else
  set rtp+=~/.vim/bundle/Vundle.vim   " set the runtime path to include Vundle and initialize
endif
call vundle#begin()                 " alternatively, pass a path: call vundle#begin('~/some/path/here')

" plugin from http://vim-scripts.org/vim/scripts.html: 直接写插件名
" plugin on GitHub repo: 用户名/插件名
" Git plugin not hosted on GitHub: 完整的git地址
" git repos on your local machine: 'file:///path/to/plugin'
Plugin 'gmarik/Vundle.vim'

" Base
Plugin 'L9'                             " Vim-scripts library
Plugin 'scrooloose/nerdtree'            " file browser
Plugin 'auto_mkdir'                     " auto_mkdir
Plugin 'Valloric/ListToggle'            " ListToggle: toggle quickfix and location-list
" Plugin 'fholgado/minibufexpl.vim'       " buffer
Plugin 'kien/ctrlp.vim'
Plugin 'FelikZ/ctrlp-py-matcher'

" status line
Plugin 'vim-airline/vim-airline'        "
Plugin 'vim-airline/vim-airline-themes' "
" Plugin 'edkolev/tmuxline.vim'
Plugin 'edkolev/promptline.vim'

" Themes
Plugin 'flazz/vim-colorschemes'         " all colorschemes of vim.org
Plugin 'tomasr/molokai'
Plugin 'altercation/vim-colors-solarized'

" Edit
Plugin 'terryma/vim-multiple-cursors'   " Sublime Text style multiple selections for Vim
Plugin 'tpope/vim-surround'             " surround
"Plugin 'kien/rainbow_parentheses.vim'   " Rainbow parentheses
Plugin 'Raimondi/delimitMate'           " auto-completion for quotes, parens, brackets

" Develop
Plugin 'Tagbar'                         " tag list
Plugin 'scrooloose/syntastic'           " syntastic: syntax check

if g:system == 'mac' && executable('clang') == 1 && (v:version > 703 || (v:version == 703 && has('patch584')))
  Plugin 'Rip-Rip/clang_complete'
  Plugin 'Valloric/YouCompleteMe'
else
  Plugin 'davidhalter/jedi-vim'
endif

" json
Plugin 'elzr/vim-json'

" Markdown
Plugin 'godlygeek/tabular'              " tabular: 文本对齐
Plugin 'plasticboy/vim-markdown'

" C/C++
Plugin 'a.vim'                          " a.vim: 头文件切换

" python
" Plugin 'python.vim'
" Plugin 'nvie/vim-flake8'
Plugin 'tmhedberg/SimpylFold'
Plugin 'jmcantrell/vim-virtualenv'

" erlang
" Plugin 'oscarh/vimerl'
Plugin 'vim-erlang/vim-erlang-compiler'
Plugin 'vim-erlang/vim-erlang-skeletons'
Plugin 'vim-erlang/vim-erlang-runtime'
Plugin 'vim-erlang/vim-erlang-omnicomplete'
" Plugin 'vim-erlang/vim-erlang-tags'
Plugin 'aerosol/vim-compot'

" lisp
Plugin 'kovisoft/slimv'

" complement
Plugin 'OmniCppComplete'

" 代码段
if (v:version > 704 || (v:version == 703))
  Plugin 'sirver/ultisnips'               " ultisnips
endif
Plugin 'honza/vim-snippets'
Plugin 'drmingdrmer/xptemplate'         " xptemplate: 感觉用于C/C++更好

" 注释
Plugin 'tpope/vim-commentary'           " comment
Plugin 'DoxygenToolkit.vim'             " doxygen

" All of your Plugins must be added before the following line
call vundle#end()            " required
filetype plugin indent on    " required

" ===============================================================================
" => General
" ===============================================================================
set nocompatible        " be iMproved, vundle required

set fileencodings=ucs-bom,utf-8,chinese
set formatoptions+=m    " 如遇Unicode值大于255的文本，不必等到空格再折行。
set formatoptions+=B    " 合并两行中文时，不在中间加空格：

set ambiwidth=single
set nrformats=          " 无论前面是否加零，都把数字作为十进制处理(在使用<C-x>, <C-a>的时候)
set history=700         " Sets how many lines of history VIM has to remember
set autoread            " Set to auto read when a file is changed from the outside
set autowrite           " Automatically save before commands like :next and :make
" set backupdir=~/.vim/backup/tmp
set nobackup            " Turn backup off
set noswapfile
set nowb
if has('mouse')
  set mouse=a
endif
if (g:system == 'cygwin')
  set mouse=
endif
" Return to last edit position when opening files
autocmd BufReadPost *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal! g`\"" |
      \ endif
set viminfo^=%                  " Remember info about open buffers on close

" ===============================================================================
" => User Interface
" ===============================================================================
set nu
set ruler                       " Always show current position
set wildignore+=*.o,*~,*.pyc     " Ignore compiled files
set wildignore+=*/tmp/*,*.so,*.swp,*.zip,*.pyc,*.o,*_build/*

if(g:system=="windows")
  set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*  " Windows ('noshellslash')
  set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe
else
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*        " Linux/MacOSX
  set wildignore+=*/tmp/*,*.so,*.swp,*.zip
endif
set so=7                        " Set 7 lines to the cursor
set hid                         " A buffer becomes hidden when it is abandoned

syntax enable
set incsearch                   " Makes search act like search in modern browsers
set backspace=eol,start,indent  " Configure backspace so it acts as it should act
set whichwrap+=<,>,h,l
set ignorecase                  " Ignore case when searching
set smartcase                   " When searching try to be smart about cases
set hlsearch                    " Highlight search results

set lazyredraw                  " Don't redraw while executing macros
set magic                       " For regular expressions turn magic on
set showmatch                   " Show matching brackets
set mat=2                       " How many tenths of a second to blink when matching brackets

set noerrorbells                " No annoying sound on errors
set novisualbell
set vb t_vb=
set lbr                         " Linebreak on 500 characters
set tm=500
set tw=500

set autoindent                  " Auto indent
set smartindent                 " Smart indent
set cindent                     " C indent
set wrap                        " Wrap lines
set cinoptions=g0

set wildmenu                    " Turn on the WiLd menu
set t_Co=256
set background=dark
" colorscheme desert
colorscheme molokai
" colorscheme solarized
" if exists('$ITERM_PROFILE')
"   let g:solarized_termcolors=256
" else
" endif

" Set extra options when running in GUI mode
if has("gui_running")
  set guifont=Monaco:h12
  " set guifont=Source_Code_Pro:h13
  if has("gui_gtk2")   "GTK2
    set guifont=Monaco\ 12, Monospace\ 12
  endif
  set guioptions-=T
  set guioptions+=e
  set guioptions-=r
  set guioptions-=L
  set guitablabel=%M\ %t
  set showtabline=1
  set linespace=2
  set noimd
  set t_Co=256
endif

set cmdheight=1                 " Height of the command bar
"Format the statusline
set laststatus=2
" set statusline=
" set statusline+=%2*%-3.3n%0*/ " buffer number
" set statusline+=%f/ " file name
" set statusline+=%h%1*%m%r%w%0* " flag
" set statusline+=[
" if v:version >= 600
"     set statusline+=%{strlen(&ft)?&ft:'none'}, " filetype
"     set statusline+=%{&encoding}, " encoding
" endif
" set statusline+=%{&fileformat}] " file format
" if filereadable(expand("$VIM/vimfiles/plugin/vimbuddy.vim"))
"     set statusline+=/ %{VimBuddy()} " vim buddy
" endif
" set statusline+=%= " right align
" set statusline+=%2*0x%-8B/ " current char
" set statusline+=%-14.(%l,%c%V%)/ %<%P " offset

" set cursorcolumn          "高亮当前列 cuc
set cursorline            "高亮当前行 cul
autocmd! InsertEnter * set cul
autocmd! InsertLeave * set nocul
"设置标记一列的背景颜色和数字一行颜色一致
hi! link SignColumn   LineNr
hi! link ShowMarksHLl DiffAdd
hi! link ShowMarksHLu DiffChange
"" for error highlight，防止错误整行标红导致看不清
highlight clear SpellBad
highlight SpellBad term=standout ctermfg=1 term=underline cterm=underline
highlight clear SpellCap
highlight SpellCap term=underline cterm=underline
highlight clear SpellRare
highlight SpellRare term=underline cterm=underline
highlight clear SpellLocal
highlight SpellLocal term=underline cterm=underline

set smarttab            " Be smart when using tabs
set shiftwidth=4        " insert 1 tab == 4 spaces
set tabstop=4           " display spaces number as tab
set softtabstop=4
set expandtab           " Use spaces instead of tabs
set list
nmap <leader>l :set list!<CR>
" set listchars=tab:\|\ ,eol:$    " display tab with '|    ', display lineend 
set listchars=tab:\|\             " display tab with '|    '
highlight BadWhitespace ctermbg=Red guibg=DarkRed
au BufNewFile,BufRead *.py,*.pyw,*.c,*.h,*.coffee match BadWhitespace /\s\+$/

" set filetype
au BufNewFile,BufRead *.spacemacs setf lisp
" FileType Specific Changes
if has ( "autocmd" )
  autocmd FileType vim setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType erlang setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType json,html,xhtml,xml,css setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType javascript setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType python setlocal ts=4 sts=4 sw=4 expandtab              "textwidth=79
endif

" ===============================================================================
" => Mappings 常用快捷键以及简写
" ===============================================================================
" F1 - help; F2 - file(nerdtree); F3 - tag(tagbar); F4 - Buffer(minibufexpl); F5 - lookupfile; F6 - tags update; <C-F6> - cscope update
let mapleader = "\<Space>"
let g:mapleader = "\<Space>"

" ---------------------------------------
" command mode
" ---------------------------------------
" w!! to sudo & write a file
cmap w!! w !sudo tee >/dev/null %

" ---------------------------------------
" 文件切换与导航
" ---------------------------------------
" Buffer mapping
nmap <leader>bd :bdelete<cr>                " Close the current buffer
nmap <leader>ba :1,1000 bd!<cr>             " Close all the buffers
nmap <leader>bn :bnext<cr>
nmap <leader>bp :bprevious<cr>
nmap <leader>cd :cd %:p:h<cr>:pwd<cr>       " Switch CWD to the directory of the open buffer
" Specify the behavior when switching between buffers
try
  set switchbuf=useopen,usetab  "newtab
  set stal=2
catch
endtry
" Tab
nmap <leader>tn :tabnew<cr>                 " Useful mappings for managing tabs
nmap <leader>to :tabonly<cr>
nmap <leader>tc :tabclose<cr>
nmap <leader>tm :tabmove
" Opens a new tab with the current buffer's path
" Super useful when editing files in the same directory
nmap <leader>te :tabedit <c-r>=expand("%:p:h")<cr>/

" ---------------------------------------
" Moving mapping
" ---------------------------------------
map j gj
map k gk
map <C-j> <C-W>j    " 窗口间切换
map <C-k> <C-W>k
map <C-h> <C-W>h
map <C-l> <C-W>l
map <leader>wj <C-W>j
map <leader>wk <C-W>k
map <leader>wh <C-W>h
map <leader>wl <C-W>l

nmap <leader>1 :resize -3<CR>
nmap <leader>2 :resize +3<CR>
nmap <leader>3 :vertical resize -3<CR>
nmap <leader>4 :vertical resize +3<CR>

if (g:system=="mac")
  nmap <D-j> <M-j>
  nmap <D-k> <M-k>
  vmap <D-j> <M-j>
  vmap <D-k> <M-k>
endif

" ---------------------------------------
" 显示控制
" ---------------------------------------
set foldenable
set foldlevel=99
set foldmethod=syntax           " default
" set foldmethod=indent
"设定自动保存折叠
"au BufWinLeave *.* silent mkview
"au BufWinLeave *.* silent! loadview

" Spell checking
nmap <leader>ss :setlocal spell!<cr>     " Pressing ,ss will toggle and untoggle spell checking
nmap <leader>sn ]s                       " Shortcuts using <leader>
nmap <leader>sp [s
nmap <leader>sa zg
nmap <leader>s? z=

" ---------------------------------------
" 编辑
" ---------------------------------------
nmap H ^
nmap L $
nmap <leader>pp :setlocal paste!<cr>    " Toggle paste mode on and off
au InsertLeave * set nopaste            " Disbale paste mode when leaving insert mode
" Delete the blank space or Windows ^M at trail of line
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc
nmap <leader>db :call DeleteTrailingWS()<CR>       " Remove blank space in lineend
nmap <leader>dm mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm   " Remove the Windows ^M
autocmd BufWrite *.py :call DeleteTrailingWS()
autocmd BufWrite *.coffee :call DeleteTrailingWS()

" 插入模式下输入一些常用文本
imap <silent> <C-D><C-D> <C-R>=strftime("%e %b %Y")<CR>
imap <silent> <C-T><C-T> <C-R>=strftime("%l:%M %p")<CR>
imap <silent> <C-C><C-C> <C-R>=string(eval(input("Calculate: ")))<CR>

" ---------------------------------------
" search, vimgrep
" ---------------------------------------
nnoremap <leader><CR> :nohl<CR>
" Search for selected text.
" vnoremap // y/<C-R>"<CR>     " use following script instead
" http://vim.wikia.com/wiki/VimTip171
let s:save_cpo = &cpo | set cpo&vim
if !exists('g:VeryLiteral')
  let g:VeryLiteral = 0
endif
function! s:VSetSearch(cmd)
  let old_reg = getreg('"')
  let old_regtype = getregtype('"')
  normal! gvy
  if @@ =~? '^[0-9a-z,_]*$' || @@ =~? '^[0-9a-z ,_]*$' && g:VeryLiteral
    let @/ = @@
  else
    let pat = escape(@@, a:cmd.'\')
    if g:VeryLiteral
      let pat = substitute(pat, '\n', '\\n', 'g')
    else
      let pat = substitute(pat, '^\_s\+', '\\s\\+', '')
      let pat = substitute(pat, '\_s\+$', '\\s\\*', '')
      let pat = substitute(pat, '\_s\+', '\\_s\\+', 'g')
    endif
    let @/ = '\V'.pat
  endif
  normal! gV
  call setreg('"', old_reg, old_regtype)
endfunction
vnoremap <silent> * :<C-U>call <SID>VSetSearch('/')<CR>/<C-R>/<CR>
vnoremap <silent> # :<C-U>call <SID>VSetSearch('?')<CR>?<C-R>/<CR>
vmap <kMultiply> *
nmap <silent> <Plug>VLToggle :let g:VeryLiteral = !g:VeryLiteral
      \\| echo "VeryLiteral " . (g:VeryLiteral ? "On" : "Off")<CR>
if !hasmapto("<Plug>VLToggle")
  nmap <unique> <Leader>vl <Plug>VLToggle
endif
let &cpo = s:save_cpo | unlet s:save_cpo

" highlight but not search the word at cursor
nnoremap <leader>h :let @/='\<<C-R>=expand("<cword>")<CR>\>'<CR>:set hls<CR>
" highlight but not search the selected text
vnoremap <leader>h :<C-U>call <SID>VSetSearch('/')<CR>/<C-R>/<CR>N

" relace selected text
vnoremap <C-r> "hy:%s/<C-r>h//gc<left><left><left>
vnoremap <C-h> ""y:%s/<C-R>=escape(@", '/\')<CR>//g<Left><Left>

" grep the word at cursor in current dir
nnoremap  <leader>gr :grep! "\b<C-R><C-W>\b"<CR>:cw<CR>

" ===============================================================================
" Development
" ===============================================================================
let python_highlight_all=1

" ===============================================================================
" 插件配置
" ===============================================================================
function! IsLoad(pluginname)
  if &runtimepath =~ a:pluginname
    return 1
  else
    return 0
  endif
endfunction
" ==> molokai
let g:molokai_original=1
let g:rehash256=1

" ==> SimpylFold
if IsLoad("SimpylFold")
  let g:SimpylFold_docstring_preview=1
endif

" ==> rainbow_parentheses
if IsLoad("rainbow_parentheses")
  let g:rbpt_colorpairs = [
        \ ['brown',       'RoyalBlue3'],
        \ ['Darkblue',    'SeaGreen3'],
        \ ['darkgray',    'DarkOrchid3'],
        \ ['darkgreen',   'firebrick3'],
        \ ['darkcyan',    'RoyalBlue3'],
        \ ['darkred',     'SeaGreen3'],
        \ ['darkmagenta', 'DarkOrchid3'],
        \ ['brown',       'firebrick3'],
        \ ['gray',        'RoyalBlue3'],
        \ ['black',       'SeaGreen3'],
        \ ['darkmagenta', 'DarkOrchid3'],
        \ ['Darkblue',    'firebrick3'],
        \ ['darkgreen',   'RoyalBlue3'],
        \ ['darkcyan',    'SeaGreen3'],
        \ ['darkred',     'DarkOrchid3'],
        \ ['red',         'firebrick3'],
        \ ]
  let g:rbpt_max = 16
  let g:rbpt_loadcmd_toggle = 0
  au VimEnter * RainbowParenthesesToggle
  au Syntax * RainbowParenthesesLoadRound
  au Syntax * RainbowParenthesesLoadSquare
  au Syntax * RainbowParenthesesLoadBraces
endif

" ===> delimitMate
if IsLoad("delimitMate")
  let delimitMate_quotes = "\" ' `"
  au FileType python,vim let b:delimitMate_quotes = "' `"
  au FileType markdown let b:delimitMate_quotes = "\" '"
  au FileType lisp,clojure let b:delimitMate_quotes = "\" `"

endif

" ===> NERDTree
if IsLoad("nerdtree")
  let g:NERDTree_title="NERDTree"
  let NERDTreeShowBookmarks=1         "一直显示书签
  "打开书签时，自动将Vim的pwd设为打开的目录
  let NERDTreeChDirMode=2
  let NERDTreeIgnore=['\.pyc$', '\~$', '\.beam$']     "ignore files in NERDTree
  " open a NERDTree automatically when vim starts up if no files were specified
  autocmd StdinReadPre * let s:std_in=1
  autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
  " close vim if the only window left open is a NERDTree
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

  nmap <silent><F2> :NERDTreeToggle<CR><CR>
  nmap <silent>ft :NERDTreeToggle<CR><CR>
endif

" ===> minibufexpl
if IsLoad("minibufexpl")
  map <Leader>mbe :MBEOpen<cr>
  map <Leader>mbc :MBEClose<cr>
  map <Leader>mbt :MBEToggle<cr>
  nmap <C-TAB>   :MBEbf<CR>
  nmap <C-S-TAB> :MBEbb<CR>
  " 下面4个选项在fholgado版本的minibufexpl中已经去除，我们自己定义这些功能
  "let g:miniBufExplMapWindowNavVim = 1
  "let g:miniBufExplMapWindowNavArrows = 1
  "let g:miniBufExplMapCTabSwitchBufs = 1
  "let g:miniBufExplModSelTarget = 1
endif

" ===> tagbar plugin
if IsLoad("tagbar")
  nmap <silent><F3> :TagbarToggle<CR>
  let g:tagbar_ctags_bin = 'ctags'
  let g:tagbar_width     = 30
  "autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()
endif

" ===> ctrlp
if IsLoad("ctrlp")
  let g:ctrlp_map = '<c-p>'
  nmap <leader>ff :CtrlP<cr>
  nmap <leader>fr :CtrlPMRU<cr>
  nmap <leader>fb :CtrlPBuffer<cr>
  nmap <leader>xb :CtrlPBuffer<cr>
  let g:ctrlp_open_multiple_files = 'v'
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/]\.(git)$',
        \ 'file': '\v\.(log|jpg|png|jpeg)$',
        \ }
  let g:ctrlp_by_filename = 1
endif

" ===> PyMatcher for CtrlP
if !has('python')
  echo 'In order to use pymatcher plugin, you need +python compiled vim'
else
  let g:ctrlp_match_func = { 'match': 'pymatcher#PyMatch' }
endif

" Set delay to prevent extra search
let g:ctrlp_lazy_update = 350
" Do not clear filenames cache, to improve CtrlP startup
" You can manualy clear it by <F5>
let g:ctrlp_clear_cache_on_exit = 0
" Set no file limit, we are building a big project
let g:ctrlp_max_files = 0
" If ag is available use it as filename list generator instead of 'find'
if executable('ag')             " The Silver Searcher
  set grepprg=ag\ --nogroup\ --nocolor
  let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --ignore ''.git'' --ignore ''.DS_Store'' --ignore ''node_modules'' --hidden -g ""'
  " ag is fast enough that CtrlP doesn't need to cache
  " let g:ctrlp_use_caching = 0
else
  set grepprg=grep\ -nrI\ --exclude-dir={CVS,'.bzr','.git','.hg','.svn'}
  if(g:system=="windows")
    let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d'  " Windows
  else
    let g:ctrlp_user_command = 'find %s -type f'        " MacOSX/Linux
  endif
endif


" ===> vim-airline
if IsLoad("vim-airline")
  let g:airline#extensions#tabline#enabled = 1
  let g:airline#extensions#tabline#left_sep = ' '
  let g:airline#extensions#tabline#left_alt_sep = '|'

  let g:airline#extensions#bufferline#enabled = 0

  let g:airline#extensions#tabline#buffer_nr_show = 1
  let g:airline#extensions#tabline#buffer_nr_format = '%s:'
  let g:airline#extensions#tabline#fnamecollapse = 1          "collopsing parent dir
  let g:airline#extensions#tabline#fnametruncate = 10         "non-active buffer name specified length
endif

" ===> ctrlp
if IsLoad("ctrlp")
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/]\.(git|hg|svn)$',
        \ 'file': '\v\.(exe|so|dll)$',
        \ 'link': 'SOME_BAD_SYMBOLIC_LINKS',
        \ }
  let g:ctrlp_max_files = 20000
  let g:ctrlp_mruf_exclude = '/tmp/.*'
  nmap <leader>p :CtrlPBuffer<cr>
endif

" ===> promptline
if  IsLoad("promptline")
  let g:promptline_preset = 'full'
  let g:promptline_theme = 'airline'
endif

" ===> syntastic
if IsLoad("syntastic")
  set statusline+=%#warningmsg#
  set statusline+=%{SyntasticStatuslineFlag()}
  set statusline+=%*

  let g:syntastic_always_populate_loc_list = 0
  let g:syntastic_auto_loc_list = 0
  let g:syntastic_check_on_open = 1
  let g:syntastic_check_on_wq = 0

  " c++11 support
  let g:syntastic_cpp_compiler = 'clang++'
  let g:syntastic_cpp_compiler_options = '-std=c++11 -stdlib=libc++'

  " python support
  " let g:syntastic_python_python_exec = '/path/to/python3'    " if use python3
  " let g:syntastic_python_checkers = ['pylint']
  let g:syntastic_python_checkers= ['flake8']
  let g:syntastic_python_flake8_post_args='--ignore=E501,E128'

  " erlang support
  " let g:syntastic_erlc_include_path = 'ebin'

  " set error or warning signs
  let g:syntastic_error_symbol = '✗'
  let g:syntastic_warning_symbol = '⚠'
  " whether to show balloons
  let g:syntastic_enable_balloons = 1
endif

if IsLoad("jedi-vim")
  let g:jedi#completions_command = "<C-E>"
endif

" ===> virtualenv
if IsLoad("virtualenv")
  " let g:virtualenv_directory = '~/.virtualenvs'
  let g:virtualenv_stl_format = '[%n]'
  set statusline+=%{virtualenv#statusline()}
endif
" py << EOF
" import os.path
" import sys
" import vim
" if 'VIRTUA_ENV' in os.environ:
"   project_base_dir = os.environ['VIRTUAL_ENV']
"   sys.path.insert(0, project_base_dir)
"   activate_this = os.path.join(project_base_dir,'bin/activate_this.py')
"   execfile(activate_this, dict(__file__=activate_this))
" EOF

" ===> OmniCompletion
" 全能(Omni)补全（代码）        CTRL-X CTRL-O
" 从上文查找补全                CTRL-P
" 从下文查找补全                CTRL-N
" 整行补全                      CTRL-X CTRL-L
" 根据当前文件里关键字补全      CTRL-X CTRL-N
" 根据字典补全                  CTRL-X CTRL-K
" 根据同义词字典补全            CTRL-X CTRL-T
" 根据头文件内关键字补全        CTRL-X CTRL-I
" 根据标签补全                  CTRL-X CTRL-]
" 补全文件名                    CTRL-X CTRL-F
" 补全宏定义                    CTRL-X CTRL-D
" 补全vim命令                   CTRL-X CTRL-V
" 用户自定义补全方式            CTRL-X CTRL-U
" 拼写建议                      CTRL-X CTRL-S
set ofu=syntaxcomplete#Complete
autocmd FileType python set omnifunc=pythoncomplete#Complete
autocmd FileType javascript set omnifunc=javascriptcomplete#CompleteJS
autocmd FileType html set omnifunc=htmlcomplete#CompleteTags
autocmd FileType css set omnifunc=csscomplete#CompleteCSS
autocmd FileType xml set omnifunc=xmlcomplete#CompleteTags
autocmd FileType php set omnifunc=phpcomplete#CompletePHP
autocmd FileType c set omnifunc=ccomplete#Complete
autocmd BufNewFile,BufRead,BufEnter *.cpp,*.hpp set omnifunc=omni#cpp#complete#Main

let OmniCpp_NamespaceSearch = 1
let OmniCpp_GlobalScopeSearch = 1
let OmniCpp_ShowAccess = 1
let OmniCpp_ShowPrototypeInAbbr = 1 " 显示函数参数列表
let OmniCpp_MayCompleteDot = 1   " 输入 .  后自动补全
let OmniCpp_MayCompleteArrow = 1 " 输入 -> 后自动补全
let OmniCpp_MayCompleteScope = 1 " 输入 :: 后自动补全
let OmniCpp_DefaultNamespaces = ["std", "_GLIBCXX_STD"]

set nocp
set infercase           "自动补全时区分大小写，默认不区分ignorecase
" 自动关闭补全窗口
au CursorMovedI,InsertLeave * if pumvisible() == 0|silent! pclose|endif
set completeopt=menuone,menu,longest
"回车即选中当前项
inoremap <expr> <CR>       pumvisible() ? "\<C-y>" : "\<CR>"
"上下左右键的行为 会显示其他信息
inoremap <expr> <Down>     pumvisible() ? "\<C-n>" : "\<Down>"
inoremap <expr> <Up>       pumvisible() ? "\<C-p>" : "\<Up>"
inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-p>\<C-n>" : "\<PageDown>"
inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-p>\<C-n>" : "\<PageUp>"

" Pmenu 是所有项的配色，PmenuSel 是选中项的配色，guibg 和 guifg 分别对应背景色和前景色。
" highlight Pmenu    guibg=darkgrey  guifg=black
" highlight PmenuSel guibg=lightgrey guifg=black
" ===============================================================================
" => clang_complete
" ===============================================================================
" if IsLoad("clang_complete")
let g:clang_complete_auto = 1
let g:clang_complete_copen = 1
let g:clang_user_options='|| exit 0'

if(g:system == 'mac')
  let g:clang_use_library = 1
  let g:clang_library_path = "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib"
elseif(g:system == 'unix')
  let g:clang_use_library = 1
  let g:clang_library_path= "/usr/lib/clang"
elseif (g:system == 'windows')
  let g:clang_use_library = 0
elseif(g:system == 'cygwin')
  let g:clang_use_library = 1
  let g:clang_library_path= "/usr/bin"
endif
" endif

if IsLoad("YouCompleteMe")
  let g:ycm_key_list_select_completion = ['<c-n>', '<Down>']
  let g:ycm_key_list_previous_completion = ['<c-p>', '<Up>']
  let g:ycm_confirm_extra_conf = 0
  let g:ycm_autoclose_preview_window_after_completion=1
  map <leader>g  :YcmCompleter GoToDefinitionElseDeclaration<CR>
endif

if IsLoad("ultisnips")
  let g:UltiSnipsUsePythonVersion=2
  let g:UltiSnipsExpandTrigger="<tab>"
  let g:UltiSnipsJumpForwardTrigger="<c-j>"
  let g:UltiSnipsJumpBackwardTrigger="<c-k>"
  " If you want :UltiSnipsEdit to split your window.
  let g:UltiSnipsEditSplit="vertical"

endif

" ===> xptemplate
if IsLoad("xptemplate")
  let g:xptemplate_key='<c-\>'
  let g:xptemplate_vars = "BRloop=\n"     "循环中的 { 重起一行
  let g:xptemplate_vars = "BRfun= "       "函数中的 { 重起一行
  " let g:xptemplate_brace_complete = '(['

  " Prevent supertab from mapping <tab> to anything.
  let g:SuperTabMappingForward = '<Plug>xpt_void'
  " Tell XPTemplate what to fall back to, if nothing matches.
  " Original SuperTab() yields nothing if g:SuperTabMappingForward was set to something it does not know.
  let g:xptemplate_fallback = '<C-r>=XPTwrapSuperTab("n")<CR>'
endif

" ===============================================================================
" => Cscope
" ===============================================================================
" C++ tags: "!ctags -R --c++-kinds=+px --fields=+iaS --extra=+q ."
" :ts tagselect, :tp 为上一个tag标记文件，:tn 为下一个tag标记文件。
" g+]直接显示ctag结果列表
" 让CTRL-]只有一个选择时自动跳转，多个选择时，出现选择列表
" map <C-]> :tselect <C-R>=expand("<cword>")<CR><CR>
" map <C-]> g<C-]>

"添加特定的（已经生成tags）的函数库的tags
autocmd FileType cpp set tags+=~/.vim/cpp_src/tags

" ===============================================================================
" => Cscope
" ===============================================================================
if has("cscope")
  set csprg=cscope
  " Use both cscope and ctag
  set cscopetag
  " Show msg when cscope db added
  set cscopeverbose
  " Use cscope for definition search first
  set cscopetagorder=0
endif


"自动加载cscope.out
" function! LoadCscope()
"     let db = findfile("cscope.out", ".;")    "从当前目录往上找，直到找到 cscope.out 这个命令能到找到cscope.out的路径。
"     if (!empty(db))
"         let path = strpart(db, 0, match(db, "/cscope.out$"))
"         set nocsverb                                "suppress 'duplicate connection' error
"         exe "cs add " . db . " " . path
"         set csverb
"     endif
" endfunction
" autocmd BufRead,BufEnter *.cpp,*.hpp call LoadCscope()

"s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方
"g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能
"d: 查找本函数调用的函数
"c: 查找调用本函数的函数
"t: 查找指定的字符串
"e: 查找egrep模式，相当于egrep功能，但查找速度快多了
"f: 查找并打开文件，类似vim的find功能
"i: 查找包含本文件的文
set cscopequickfix=s-,g-,c-,t-,e-,f-,i-,d-
nmap <C-@>s :cs find s <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <C-@>g :cs find g <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <C-@>c :cs find c <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <C-@>t :cs find t <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <C-@>e :cs find e <C-R>=expand("<cword>")<CR><CR>:copen<CR>
nmap <C-@>f :cs find f <C-R>=expand("<cfile>")<CR><CR>:copen<CR>
nmap <C-@>i :cs find i ^<C-R>=expand("<cfile>")<CR>$<CR>:copen<CR>
nmap <C-@>d :cs find d <C-R>=expand("<cword>")<CR><CR>:copen<CR>

" Folding rules {{{
set foldenable                  " enable folding
set foldcolumn=2                " add a fold column
set foldmethod=marker           " detect triple-{ style fold markers
set foldlevelstart=99           " start out with everything folded
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
" which commands trigger auto-unfold
function! MyFoldText()
  let line = getline(v:foldstart)

  let nucolwidth = &fdc + &number * &numberwidth
  let windowwidth = winwidth(0) - nucolwidth - 3
  let foldedlinecount = v:foldend - v:foldstart

  " expand tabs into spaces
  let onetab = strpart('          ', 0, &tabstop)
  let line = substitute(line, '\t', onetab, 'g')

  let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
  let fillcharcount = windowwidth - len(line) - len(foldedlinecount) - 4
  return line . ' …' . repeat(" ",fillcharcount) . foldedlinecount . ' '
endfunction
set foldtext=MyFoldText()

"c/c++/javascript/java fold method
autocmd filetype c,cpp,javascript,java set foldmarker={,}

nnoremap zO zCzO
nnoremap ,z zMzv
"}}}
