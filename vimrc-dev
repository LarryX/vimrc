" ============================================================================
" vimrc for develop
" Maintainer: ovsoil
"       hxyumail@gmail.com
"       http://ovsoil.com
" Create Date:
"       01/09/2015
" ============================================================================

" ============================================================================
" Vim-plug initialization
" ============================================================================
let vim_plug_just_installed = 0
if has('nvim')
  let vim_plug_path = expand('~/.local/share/nvim/site/autoload/plug.vim')
else
  let vim_plug_path = expand('~/.vim/autoload/plug.vim')
endif
if !filereadable(vim_plug_path)
  echo "Installing vim-plug ..."
  echo ""
  if has('nvim')
    silent !mkdir -p ~/.local/share/nvim/site/autoload 
    silent !curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
    " silent !curl -fLo fnameescape(vim_plug_path) --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  else
    silent !mkdir -p ~/.vim/autoload
    silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
  endif
  let vim_plug_just_installed = 1
endif

" manually load vim-plug the first time
if vim_plug_just_installed
  :execute 'source '.fnameescape(vim_plug_path)
endif

" ============================================================================
" Platform
" ============================================================================
let g:system=""
let g:homedir=""
if (has("win32") || has("win95") || has("win64") || has("win16"))
  let g:system="windows"
elseif (has('win32unix'))  " Cygwin
  let g:system="cygwin"
elseif (has("unix"))
  let g:system="unix"
  if ( system('uname') =~ "Darwin")          " ~:去除控制字符
    let g:system="mac"
  endif
endif

if(g:system=="windows")
  set ffs=dos,unix,mac
else
  set ffs=unix,dos,mac
  set encoding=utf8
endif

" ============================================================================
" Active plugins
" ============================================================================
call plug#begin('~/.vim/plugged')

" Plugins from github repos:
" Base
Plug 'tomtom/tlib_vim'                          " This library provides some utility functions
Plug 'auto_mkdir'                               " auto_mkdir
Plug 'scrooloose/nerdtree'                      " Better file browser
Plug 'Valloric/ListToggle'                      " ListToggle: toggle quickfix and location-list
Plug 'ctrlpvim/ctrlp.vim'                       " Code and files fuzzy finder
Plug 'fisadev/vim-ctrlp-cmdpalette'             " Extension to ctrlp, for fuzzy command finder
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'easymotion/vim-easymotion'
Plug 'IndexedSearch'                            " Search results counter
Plug 'mhinz/vim-startify'
if executable('ack')
  " Plug 'mileszs/ack.vim'                      " Ack code search (requires ack)
endif

" Enhancement
Plug 'Shougo/denite.nvim'
Plug 'rosenfeld/conque-term'            " Consoles as buffers
Plug 'fisadev/FixedTaskList.vim'        " Pending tasks list
Plug 'terryma/vim-multiple-cursors'     " Sublime Text style multiple selections for Vim
Plug 'tpope/vim-surround'               " surround
Plug 'terryma/vim-expand-region'        " visually select increasingly larger regions
Plug 'Raimondi/delimitMate'             " auto-completion for quotes, parens, brackets
Plug 'tpope/vim-repeat'
Plug 'godlygeek/tabular'                " aligning text

" Write
Plug 'junegunn/limelight.vim'
Plug 'junegunn/goyo.vim'

" User Interface
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'flazz/vim-colorschemes'
Plug 'tomasr/molokai'
Plug 'altercation/vim-colors-solarized'
Plug 'fisadev/fisa-vim-colorscheme'
" Plug 'liuchengxu/space-vim-dark'
Plug 'morhetz/gruvbox'
" Plug 'Wombat'                           " Gvim colorscheme

" Develop
Plug 'w0rp/ale'
" let s:vim8 = has('patch-8.0.0039') && exists('*job_start')      " if vim8 or neovim
" if s:vim8
"   Plug 'w0rp/ale'
" else
"   Plug 'scrooloose/syntastic'
" endif
Plug 'michaeljsmith/vim-indent-object'  " Indent text object
Plug 'majutsushi/tagbar'                " Class/module browser
Plug 'tpope/vim-fugitive'
Plug 'airblade/vim-gitgutter'           " Git/mercurial/.. diff icons
Plug 'matchit.zip'                      " XML/HTML tags navigation
Plug 'mattn/emmet-vim'                  " Zen coding

" commenter
" Plug 'tpope/vim-commentary'             " comment
Plug 'scrooloose/nerdcommenter'         " Code commenter
Plug 'DoxygenToolkit.vim'               " doxygen
" complete
Plug 'Shougo/neocomplcache.vim'         " Better autocompletion
" if g:system == 'mac' && executable('clang') == 1 && (v:version > 703 || (v:version == 703 && has('patch584')))
"   Plug 'Rip-Rip/clang_complete'
"   Plug 'Valloric/YouCompleteMe'
" endif
" snippets manager (SnipMate), dependencies, and snippets repo
" Plug 'drmingdrmer/xptemplate'         " xptemplate
" Plug 'sirver/ultisnips'               " ultisnips
Plug 'honza/vim-snippets'
Plug 'garbas/vim-snipmate'

" json
Plug 'elzr/vim-json'

" markdown
Plug 'plasticboy/vim-markdown'
Plug 'mzlogin/vim-markdown-toc'
Plug 'JamshedVesuna/vim-markdown-preview'

" c/c++

" python
Plug 'klen/python-mode'
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'fisadev/vim-isort'                " Automatically sort python imports
Plug 'tmhedberg/SimpylFold'
if has('python')
  Plug 'pignacio/vim-yapf-format'       " YAPF formatter for Python
endif

" javascript
Plug 'pangloss/vim-javascript'
Plug 'kchmck/vim-coffee-script'
" html
Plug 'mattn/emmet-vim'
" css
" Plug 'lilydjwg/colorizer'           " Paint css colors with the real color

" ruby on rail
Plug 'tpope/vim-rails'

" erlang
" Plug 'oscarh/vimerl'
Plug 'vim-erlang/vim-erlang-compiler'
Plug 'vim-erlang/vim-erlang-skeletons'
Plug 'vim-erlang/vim-erlang-runtime'
Plug 'vim-erlang/vim-erlang-omnicomplete'
Plug 'vim-erlang/vim-erlang-tags'
Plug 'aerosol/vim-compot'

" lisp
Plug 'kovisoft/slimv'

call plug#end()

" ============================================================================
" Install plugins the first time vim runs
" ============================================================================
if vim_plug_just_installed
  echo "Installing Bundles, please ignore key map error messages"
  :PlugInstall
endif

" General Vim settings and mappings
" ============================================================================
" General
" ============================================================================
set nocompatible                                   " no vi-compatible
filetype plugin indent on                          " allow plugins by file type (required for plugins!)
set wildignore+=*.o,*~,*.so,*.swp,*.zip,*.pyc      " Ignore compiled files
set wildignore+=*_build/*
if(g:system=="windows")
  set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*  " Windows ('noshellslash')
  set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe
else
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*        " Linux/MacOSX
  set wildignore+=*/tmp/*,*.so,*.swp,*.zip
endif
set fileencodings=ucs-bom,utf-8,chinese
set formatoptions+=m                              " 如遇Unicode值大于255的文本，不必等到空格再折行。
set formatoptions+=B                              " 合并两行中文时，不在中间加空格：
set ambiwidth=single
set nrformats=                                    " 无论前面是否加零，都把数字作为十进制处理(在使用<C-x>, <C-a>的时候)
set autoread                                      " Set to auto read when a file is changed from the outside

if !has('nvim') 
  " backup, swap and undos storage
  set noswapfile
  set directory=~/.vim/dirs/tmp     " directory to place swap files in
  set backup                        " make backup files
  " set nobackup                      " default: off
  " set nowritebackup                 " default: on
  set backupdir=~/.vim/dirs/backups " where to put backup files
  set undofile                      " persistent undos - undo after you re-open the file
  set undodir=~/.vim/dirs/undos
  set viminfo+=n~/.vim/dirs/viminfo
  " create needed directories if they don't exist
  if !isdirectory(&backupdir)
    call mkdir(&backupdir, "p")
  endif
  if !isdirectory(&directory)
    call mkdir(&directory, "p")
  endif
  if !isdirectory(&undodir)
    call mkdir(&undodir, "p")
  endif
  set viminfo^=%                  " Remember info about open buffers on close
endif

" Return to last edit position when opening files
autocmd BufReadPost *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal! g`\"" |
      \ endif

" ============================================================================
" User Interface
" ============================================================================
set nu                          " show line numbers
set ruler                       " Always show current position
set scrolloff=7                 " when scrolling, 7 lines away from screen border
set hid                         " A buffer becomes hidden when it is abandoned
" status line
set laststatus=2
set statusline=%<%f\ %h%m%r%=%k[%{(&fenc==\"\")?&enc:&fenc}%{(&bomb?\",BOM\":\"\")}]\ %-14.(%l,%c%V%)\ %P
" autocompletion of files and commands behaves like shell
" (complete only the common part, list the options that match)
set wildmode=list:longest
" Comment this line to enable autocompletion preview window
" (displays documentation related to the selected completion option)
" Disabled by default because preview makes the window flicker
set completeopt-=preview

syntax on                       " syntax highlight on
set incsearch                   " incremental search
set hlsearch                    " highlighted search results
set backspace=eol,start,indent  " Configure backspace so it acts as it should act
set whichwrap+=<,>,h,l
set ignorecase                  " Ignore case when searching
set smartcase                   " When searching try to be smart about cases
set hlsearch                    " Highlight search results

set lazyredraw                  " Don't redraw while executing macros
set magic                       " For regular expressions turn magic on
set showmatch                   " Show matching brackets
set mat=2                       " tenths of a second to blink when matching brackets

set noerrorbells                " No annoying sound on errors
set novisualbell
set vb t_vb=
set lbr                         " Linebreak on 500 characters
set tm=500
set tw=500

set autoindent                  " Auto indent
set smartindent                 " Smart indent
set cindent                     " C indent
set wrap                        " Wrap lines
set cinoptions=g0

" use 256 colors when possible
if (&term =~? 'mlterm\|xterm\|xterm-256\|screen-256\|gnome-terminal\|rxvt-unicode-256color') || has('nvim')
  let &t_Co = 256
  colorscheme gruvbox
  "colorscheme molokai
else
  colorscheme delek
endif
set background=dark

" Set extra options when running in GUI mode
if has('gui_running')
  colorscheme wombat
  " colorscheme gruvbox
  if has("mac") || has("macunix")
    set guifont=Monaco\ for\ Powerline:h13
  elseif has("win32") || has("win64")
    set guifont=Monaco\ for\ Powerline:h14:cANSI
    set renderoptions=type:directx,renmode:5
  endif
  " set guifont=Source_Code_Pro:h13
  set guioptions-=T   " no toobar
  set guioptions-=r   " no right scroolbar
  set guioptions-=L   " no left scrollbar except there is a vertically split windows
  set guitablabel=%M\ %t
  set showtabline=0   " no tabine
  set linespace=2
  set noimd
  set t_Co=256
  set lines=40
  set columns=160
endif

set smarttab                      " Be smart when using tabs
set expandtab                     " Use spaces instead of tabs
set tabstop=4                     " display spaces number as tab
set softtabstop=4
set shiftwidth=4                  " insert 1 tab == 4 spaces
set list
nmap <leader>l :set list!<cr>
" set listchars=tab:\|\ ,eol:$    " display tab with '|    ', display lineend 
set listchars=tab:\|\             " display tab with '|    '
highlight BadWhitespace ctermbg=Red guibg=DarkRed
au BufNewFile,BufRead *.py,*.pyw,*.c,*.h,*.coffee match BadWhitespace /\s\+$/

" set filetype
au BufNewFile,BufRead *.spacemacs setf lisp
" FileType Specific Changes
if has ( "autocmd" )
  autocmd FileType vim setlocal ts=2 sts=2 sw=2 expandtab
  " autocmd FileType erlang setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType json,html,xhtml,xml,css,htmldjango setlocal ts=2 sts=2 sw=2 expandtab
  " autocmd FileType javascript setlocal ts=2 sts=2 sw=2 expandtab
endif

" set cursorcolumn          "高亮当前列 cuc
" set cursorline            "高亮当前行 cul
" autocmd! InsertEnter * set cul
" autocmd! InsertLeave * set nocul

"设置标记一列的背景颜色和数字一行颜色一致
hi! link SignColumn   LineNr
hi! link ShowMarksHLl DiffAdd
hi! link ShowMarksHLu DiffChange
"" for error highlight，防止错误整行标红导致看不清
highlight clear SpellBad
highlight SpellBad term=standout ctermfg=1 term=underline cterm=underline
highlight clear SpellCap
highlight SpellCap term=underline cterm=underline
highlight clear SpellRare
highlight SpellRare term=underline cterm=underline
highlight clear SpellLocal
highlight SpellLocal term=underline cterm=underline

"auto save folding
"au BufWinLeave *.* silent mkview
"au BufWinLeave *.* silent! loadview
set foldenable                  " enable folding
" set foldcolumn=2                " add a fold column
set foldmethod=syntax           " default
set foldlevel=20                " start out with everything folded

" ============================================================================
" Mapping
" ============================================================================
let mapleader = "\<Space>"
let g:mapleader = "\<Space>"

function! HasHelp()
  " Save current window number to revert.
  let nwin = 1
  while 1
    let nbuf = winbufnr(nwin)
    " all window processed, there is no help buftype, return 0
    if nbuf == -1
      return 0
    endif
    " if there is help buftype, return 1
    if getbufvar(nbuf, '&buftype') ==# 'help'
      return 1
    else
      let nwin = nwin + 1
    endif
  endwhile
endfunction

function! ToggleHelp()
  if HasHelp()
    :helpclose
  else
    :help
  endif
endfunction

" F1 - help; F2 - file(nerdtree); F3 - tag(tagbar); F4 - tasklist
" save as sudo
ca w!! w !sudo tee "%"

nmap <silent><F1> :call ToggleHelp()<cr>
nmap <leader>hh :call ToggleHelp()<cr>
nmap <leader>hk :Maps<CR>

" ---------------------------------------
" command line map
" ---------------------------------------
:cnoremap <C-A> <Home>
:cnoremap <C-F> <Right>
:cnoremap <C-B> <Left>
:cnoremap <Esc>b <S-Left>
:cnoremap <Esc>f <S-Right>

" ---------------------------------------
" map for terminal in neovim
" ---------------------------------------
if has('nvim')
"   let g:term_buf = 0
"   function! Term_toggle()
"     1wincmd w
"     if g:term_buf == bufnr("")
"       setlocal bufhidden=hide
"       close
"     else
"       rightbelow new
"       12winc -
"       try
"         exec "buffer ".g:term_buf
"       catch
"         call termopen("bash", {"detach": 0})
"         let g:term_buf = bufnr("")
"       endtry
"       set laststatus=0
"       startinsert!
"     endif
"   endfunction
"   nnoremap <space>tt :call Term_toggle()<cr>

  " Terminal go back to normal mode
  tnoremap <Esc> <C-\><C-n>
  " When switching to terminal windows it goes into insert mode automatically
  au BufEnter * if &buftype == 'terminal' | :startinsert | endif
endif

" ---------------------------------------
" files navigation
" ---------------------------------------
" Buffer
nmap <leader>bn :bnext<cr>
nmap <leader>bp :bprevious<cr>
nmap <Leader>b1 :1b<CR>
nmap <Leader>b2 :2b<CR>
nmap <Leader>b3 :3b<CR>
nmap <Leader>b4 :4b<CR>
nmap <Leader>b5 :5b<CR>
nmap <Leader>b6 :6b<CR>
nmap <Leader>b7 :7b<CR>
nmap <Leader>b8 :8b<CR>
nmap <Leader>b9 :9b<CR>
nmap <Leader>b0 :10b<CR>
nmap <leader>bd :bdelete<cr>          " Close the current buffer
nmap <leader>ba :1,1000 bd!<cr>       " Close all the buffers
nmap <leader>b<tab> :b#<cr>           " switch between most recently buffer
" Ngb to jump to buffer number N
let c = 1
while c <= 99
  execute "nnoremap " . c . "gb :" . c . "b\<CR>"
  let c += 1
endwhile
nmap <leader>cd :cd %:p:h<cr>:pwd<cr>       " Switch CWD to the directory of the open buffer
" Specify the behavior when switching between buffers
try
  set switchbuf=useopen,usetab        " newtab
  set stal=2
catch
endtry

" Tab
" No Tab, I rarely use tab

" ---------------------------------------
" windows Moving
" ---------------------------------------
map j gj
map k gk
nmap H ^
nmap L $
map <leader>wj <C-W>j
map <leader>wk <C-W>k
map <leader>wh <C-W>h
map <leader>wl <C-W>l
" nmap <leader>1 :re                " always show status line - use 2 linessize -3<cr>
" nmap <leader>2 :resize +3<cr>
" nmap <leader>3 :vertical resize -3<cr>
" nmap <leader>4 :vertical resize +3<cr>
if (g:system=="mac")
  nmap <D-j> <M-j>
  nmap <D-k> <M-k>
  vmap <D-j> <M-j>
  vmap <D-k> <M-k>
endif

" ---------------------------------------
" folding
" ---------------------------------------
nnoremap zO zCzO
nnoremap ,z zMzv

" ---------------------------------------
" Edit
" ---------------------------------------
set pastetoggle=<leader>pt                      " Toggle paste mode
nmap <leader>yy "+yy
nmap <leader>dd "+d
vmap <leader>dd "+d
nmap <leader>yy "+y
vmap <leader>yy "+y
nmap <leader>pp "+p
vmap <leader>pp "+p
nmap <leader>pP "+P
vmap <leader>pP "+P
au InsertLeave * set nopaste                    " Disbale paste mode when leaving insert mode
map <leader>= <Esc>:%!python -m json.tool<cr>   " format json
" if (executable('pbcopy') || executable('xclip') || executable('xsel')) && has('clipboard')
"   set clipboard=unnamed
" endif

" Delete the blank space or Windows ^M at trail of line
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc
nmap <leader>db :call DeleteTrailingWS()<cr>       " Remove blank space in lineend
nmap <leader>dm mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm   " Remove the Windows ^M
autocmd BufWrite *.py :call DeleteTrailingWS()
autocmd BufWrite *.coffee :call DeleteTrailingWS()

" insert some usefull text
imap <silent> <C-D><C-D> <C-R>=strftime("%e %b %Y")<cr>
imap <silent> <C-T><C-T> <C-R>=strftime("%l:%M %p")<cr>
imap <silent> <C-C><C-C> <C-R>=string(eval(input("Calculate: ")))<cr>

" ---------------------------------------
" search, vimgrep
" ---------------------------------------
if executable('ag')             " The Silver Searcher
  set grepprg=ag\ --nogroup\ --nocolor
  let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --ignore .git --ignore .DS_Store --ignore node_modules --ignore "**/*.pyc" --hidden -g ""'
  " ag is fast enough that CtrlP doesn't need to cache
  " let g:ctrlp_use_caching = 0
else
  set grepprg=grep\ -nrI\ --exclude-dir={CVS,'.bzr','.git','.hg','.svn'}
  if(g:system=="windows")
    let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d'  " Windows
  else
    " MacOSX/Linux
    let g:ctrlp_user_command = [
          \ '.git', 'cd %s && git ls-files . -co --exclude-standard',
          \ 'find %s -type f'
          \ ]
  endif
endif

nnoremap <leader><cr> :nohl<cr>
" Search for selected text.
" vnoremap // y/<C-R>"<cr>     " use following script instead
" http://vim.wikia.com/wiki/VimTip171
let s:save_cpo = &cpo | set cpo&vim
if !exists('g:VeryLiteral')
  let g:VeryLiteral = 0
endif
function! s:VSetSearch(cmd)
  let old_reg = getreg('"')
  let old_regtype = getregtype('"')
  normal! gvy
  if @@ =~? '^[0-9a-z,_]*$' || @@ =~? '^[0-9a-z ,_]*$' && g:VeryLiteral
    let @/ = @@
  else
    let pat = escape(@@, a:cmd.'\')
    if g:VeryLiteral
      let pat = substitute(pat, '\n', '\\n', 'g')
    else
      let pat = substitute(pat, '^\_s\+', '\\s\\+', '')
      let pat = substitute(pat, '\_s\+$', '\\s\\*', '')
      let pat = substitute(pat, '\_s\+', '\\_s\\+', 'g')
    endif
    let @/ = '\V'.pat
  endif
  normal! gV
  call setreg('"', old_reg, old_regtype)
endfunction
vnoremap <silent> * :<C-U>call <SID>VSetSearch('/')<cr>/<C-R>/<cr>
vnoremap <silent> # :<C-U>call <SID>VSetSearch('?')<cr>?<C-R>/<cr>
vmap <kMultiply> *
nmap <silent> <Plug>VLToggle :let g:VeryLiteral = !g:VeryLiteral
      \\| echo "VeryLiteral " . (g:VeryLiteral ? "On" : "Off")<cr>
if !hasmapto("<Plug>VLToggle")
  nmap <unique> <Leader>vl <Plug>VLToggle
endif
let &cpo = s:save_cpo | unlet s:save_cpo

" highlight but not search the word at cursor
nnoremap <leader>h :let @/='\<<C-R>=expand("<cword>")<cr>\>'<cr>:set hls<cr>
" highlight but not search the selected text
vnoremap <leader>h :<C-U>call <SID>VSetSearch('/')<cr>/<C-R>/<cr>N

" replace selected text
vnoremap <leader>sr ""y:%s/<C-R>=escape(@", '/\')<cr>//gc<left><Left><Left>
vnoremap <leader>sR ""y:%s/<C-R>=escape(@", '/\')<cr>//g<Left><Left>
nnoremap <leader>sr :%s/<C-R><C-W>//gc"<left><left><left><left>
nnoremap <leader>sr :%s/<C-R><C-W>//g"<left><left><left>

" grep the word at cursor in current dir
nnoremap <leader>sw :grep! "\b<C-R><C-W>\b"<cr>:cw<cr>
vnoremap <leader>sw y:grep! '<C-R>"' .<cr>:cw<cr>

command -nargs=+ -complete=file -bar Search silent! grep! <args>|cwindow|redraw!
nnoremap <leader>ss :Search<Space>''<left>

vnoremap <silent> y y`]
vnoremap <silent> p p`]
nnoremap <silent> p p`]

" ============================================================================
" Plugins settings and mappings
" ============================================================================
function! IsLoad(pluginname)
  if &runtimepath =~ a:pluginname
    return 1
  else
    return 0
  endif
endfunction

if IsLoad('nerdtree')
  if has('nvim')
    let mymapping_file = expand('~/.config/nvim/nerdtree_plugin/mymapping.vim')
  else
    let mymapping_file = expand('~/.vim/nerdtree_plugin/mymapping.vim')
  endif
  if !filereadable(mymapping_file)
    echo "Installing custom mapping for nerdtree ..."
    echo ""
    if has('nvim')
      silent !mkdir -p ~/.config/nvim/nerdtree_plugin
      silent !curl -fLo ~/.config/nvim/nerdtree_plugin/mymapping.vim --create-dirs https://raw.githubusercontent.com/ovsoil/vimrc/master/nerdtree_plugin/mymapping.vim
    else
      silent !mkdir -p ~/.vim/nerdtree_plugin
      silent !curl -fLo ~/.vim/nerdtree_plugin/mymapping.vim --create-dirs https://raw.githubusercontent.com/ovsoil/vimrc/master/nerdtree_plugin/mymapping.vim
    endif
  endif
  nmap <silent><F2> :NERDTreeToggle<cr><cr>
  nmap <leader>ft :NERDTreeToggle<cr><cr>
  let g:NERDTree_title="NERDTree"
  let NERDTreeShowBookmarks=1         "allways show bookmarks
  let NERDTreeChDirMode=2             "auto set pwd when open bookmarks
  let NERDTreeIgnore=['node_modules', 'bower_components', '\.pyc$', '\.pyo$', '\~$', '\.beam$']     "ignore files in NERDTree
  " open a NERDTree automatically when vim starts up if no files were specified
  " autocmd StdinReadPre * let s:std_in=1
  " autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif
  " open NERDTree automatically when vim starts up on opening a directory
  autocmd StdinReadPre * let s:std_in=1
  autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif
  " close vim if the only window left open is a NERDTree
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

  if !nerdtree#runningWindows()
    let g:NERDTreeDirArrowExpandable = '▸'
    let g:NERDTreeDirArrowCollapsible = '▾'
  else
    let g:NERDTreeDirArrowExpandable = '+'
    let g:NERDTreeDirArrowCollapsible = '~'
  endif
endif

if IsLoad('tagbar')
  nmap <silent><F3> :TagbarToggle<cr>
  let g:tagbar_ctags_bin = 'ctags'
  let g:tagbar_width     = 30
  let g:tagbar_autofocus = 1      " autofocus on tagbar open
  "autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()
endif

if IsLoad('fixedtasklist')
  map <F4> :TaskList<cr>                " show pending tasks list
  map <leader>lt :TaskList<cr>          " show pending tasks list
endif

if IsLoad('ctrlp')
  " file finder mapping, avoid open file in nerdtree window
  nmap <silent> <expr> <Leader>ff (expand('%') =~ 'NERD_tree' ? "\<c-w>\<c-w>" : '').":CtrlP\<cr>"
  nmap <leader>fj :e .<cr>
  nmap <leader>fr :CtrlPMRU<cr>
  nmap <leader>fb :CtrlPBuffer<cr>
  nmap <leader>bb :CtrlPBuffer<cr>
  nmap <leader>fe :CtrlP <c-r>=expand("%:p:h")<cr><cr>
  " tags (symbols) in current file finder mapping
  nmap ,g :CtrlPBufTag<cr>
  nmap <leader>st :CtrlPBufTag<cr>
  " tags (symbols) in all files finder mapping
  nmap ,G :CtrlPBufTagAll<cr>
  nmap <leader>sT :CtrlPBufTagAll<cr>
  " general code finder in all files mapping
  nmap ,f :CtrlPLine<cr>
  nmap <leader>sl :CtrlPLine<cr>
  " commands finder mapping
  nmap ,c :CtrlPCmdPalette<cr>
  nmap <leader>sc :CtrlPCmdPalette<cr>
  " to be able to call CtrlP with default search text
  function! CtrlPWithSearchText(search_text, ctrlp_command_end)
    execute ':CtrlP' . a:ctrlp_command_end
    call feedkeys(a:search_text)
  endfunction
  " same as previous mappings, but calling with current word as default text
  nmap ,wg :call CtrlPWithSearchText(expand('<cword>'), 'BufTag')<cr>
  nmap ,wG :call CtrlPWithSearchText(expand('<cword>'), 'BufTagAll')<cr>
  nmap ,wf :call CtrlPWithSearchText(expand('<cword>'), 'Line')<cr>
  nmap ,we :call CtrlPWithSearchText(expand('<cword>'), '')<cr>
  nmap ,pe :call CtrlPWithSearchText(expand('<cfile>'), '')<cr>
  nmap ,wc :call CtrlPWithSearchText(expand('<cword>'), 'CmdPalette')<cr>
  " let g:ctrlp_working_path_mode = 0             " don't change working directory
  let g:ctrlp_working_path_mode = 'ra'        " smart change working directory
  " ignore these files and folders on file finder
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/](\.git|\.hg|\.svn|node_modules)$',
        \ 'file': '\.(o|swp|beam|pyc|pyo|wav|mp3|ogg|blend)$\|\.(log|jpg|png|jpeg)$|__init__\.py',
        \ }
endif

if IsLoad('ack')
  " simple recursive grep
  nmap ,r :Ack
  nmap ,wr :Ack <cword><cr>
endif

if IsLoad('vim-startify')
  " let g:startify_list_order = [
  "       \ ['   Recent Files:'],
  "       \ 'files',
  "       \ ['   Project:'],
  "       \ 'dir',
  "       \ ['   Sessions:'],
  "       \ 'sessions',
  "       \ ['   Bookmarks:'],
  "       \ 'bookmarks',
  "       \ ['   Commands:'],
  "       \ 'commands',
  "       \ ]
  nnoremap <silent><leader>bh :Startify<CR>
endif

if IsLoad('vim-easymotion')
  " <leader><leader>w : word, 在单词间移动，往前
  " <leader><leader>b : back, 在单词间移动，往后
  " <leader><leader>s : search, 字符搜索跳转，双向
  " <leader><leader>f : forward, 向前搜索字符
  " <leader><leader>j
  " <leader><leader>k
  " Jump to line
  map <leader>jl <Plug>(easymotion-bd-jk)
  nmap <leader>jl <Plug>(easymotion-overwin-line)
  " Jump to word
  map  <leader>jw <Plug>(easymotion-bd-w)
  nmap <leader>jw <Plug>(easymotion-overwin-w)
endif

if IsLoad('molokai')
  let g:molokai_original=1
  let g:rehash256=1
endif

if IsLoad('vim-airline')
  if(g:system=="mac")
    let g:airline_powerline_fonts = 1
  endif
  let g:airline_theme = 'bubblegum'
  let g:airline#extensions#default#layout = [
        \ [ 'a', 'b', 'c' ],
        \ [ 'x', 'y', 'z', 'error', 'warning' ]
        \ ]
  let g:airline#extensions#tabline#enabled = 1
  let g:airline#extensions#tabline#left_sep = ' '
  let g:airline#extensions#tabline#left_alt_sep = '|'
  let g:airline#extensions#tabline#buffer_nr_show = 1
  let g:airline#extensions#tabline#buffer_nr_format = '%s:'
  let g:airline#extensions#tabline#fnamecollapse = 1          "collopsing parent dir
  let g:airline#extensions#tabline#fnametruncate = 10         "non-active buffer name specified length
  let g:airline#extensions#bufferline#enabled = 0
  let g:airline#extensions#whitespace#enabled = 0
endif

if IsLoad('vim-expand-region')
  vmap v <Plug>(expand_region_expand)
  vmap <C-v> <Plug>(expand_region_shrink)
endif 

if IsLoad('delimitmate')
  let delimitMate_quotes = "\" ' `"
  au FileType python,vim let b:delimitMate_quotes = "' `"
  au FileType markdown let b:delimitMate_quotes = "\" '"
  au FileType lisp,clojure let b:delimitMate_quotes = "\" `"

endif

if IsLoad('ale')
  let g:ale_linters = {
        \   'javascript': ['eslint'],
        \   'erlang': ['erlc'],
        \   'python': ['flake8'],
        \}
  let g:ale_sign_column_always = 0
  let g:ale_sign_error = '>'
  let g:ale_sign_warning = '-'
  let g:ale_lint_on_save = 1
  let g:ale_lint_on_text_changed = 1
  let g:ale_lint_on_enter = 1
  " Map movement through errors without wrapping.
  nmap <silent> <C-k> <Plug>(ale_previous)
  nmap <silent> <C-j> <Plug>(ale_next)
endif


if IsLoad('syntastic')
  " show list of errors and warnings on the current file
  nmap <leader>le :Errors<cr>
  let g:syntastic_always_populate_loc_list = 0
  let g:syntastic_auto_loc_list = 0
  let g:syntastic_check_on_open = 1
  let g:syntastic_check_on_wq = 0
  " don't put icons on the sign column (it hides the vcs status icons of signify)
  let g:syntastic_enable_signs = 0

  " c++11 support
  let g:syntastic_cpp_compiler = 'clang++'
  let g:syntastic_cpp_compiler_options = '-std=c++11 -stdlib=libc++'

  " python support
  " let g:syntastic_python_python_exec = '/path/to/python3'    " if use python3
  " let g:syntastic_python_checkers = ['pylint']
  let g:syntastic_python_checkers= ['flake8']
  let g:syntastic_python_flake8_post_args='--ignore=E501,E128'

  " erlang support
  " let g:syntastic_erlc_include_path = 'ebin'

  " custom icons (enable them if you use a patched font, and enable the previous
  " setting)
  "let g:syntastic_error_symbol = '✗'
  "let g:syntastic_warning_symbol = '⚠'
  "let g:syntastic_style_error_symbol = '✗'
  "let g:syntastic_style_warning_symbol = '⚠'

  " whether to show balloons
  let g:syntastic_enable_balloons = 1
endif

if IsLoad('nerdcommenter')
  " Add spaces after comment delimiters by default
  let g:NERDSpaceDelims = 1
  " Use compact syntax for prettified multi-line comments
  let g:NERDCompactSexyComs = 1
  " Align line-wise comment delimiters flush left instead of following code indentation
  let g:NERDDefaultAlign = 'left'
  " Set a language to use its alternate delimiters by default
  let g:NERDAltDelims_java = 1
  " Add your own custom formats or override the defaults
  let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
  " Allow commenting and inverting empty lines (useful when commenting a region)
  let g:NERDCommentEmptyLines = 1
  " Enable trimming of trailing whitespace when uncommenting
  let g:NERDTrimTrailingWhitespace = 1
endif

if IsLoad('python-mode')
  " don't use linter, we use syntastic for that
  let g:pymode_lint_on_write = 0
  let g:pymode_lint_signs = 0
  " don't fold python code on open
  let g:pymode_folding = 0
  " don't load rope by default. Change to 1 to use rope
  let g:pymode_rope = 0
  " open definitions on same window, and custom mappings for definitions and
  " occurrences
  " Override go-to.definition key shortcut to Ctrl-]
  let g:pymode_rope_goto_definition_bind = "<C-]>"
  " let g:pymode_rope_goto_definition_bind = ',d'
  let g:pymode_rope_goto_definition_cmd = 'e'
  " Override run current python file key shortcut to Ctrl-Shift-e
  let g:pymode_run_bind = "<C-S-e>"
  " Override view python doc key shortcut to Ctrl-Shift-d
  " let g:pymode_doc_bind = "<C-S-d>"
  nmap ,D :tab split<cr>:PymodePython rope.goto()<cr>
  nmap ,o :RopeFindOccurrences<cr>

  let g:pymode_virtualenv = 1
  " let g:pymode_virtualenv_path = $VIRTUAL_ENV
endif

if IsLoad("simpyfold")
  let g:SimpylFold_docstring_preview=1
endif

if IsLoad('neocomplcache')
  " most of them not documented because I'm not sure how they work
  " (docs aren't good, had to do a lot of trial and error to make it play nice)
  let g:neocomplcache_enable_at_startup = 1
  let g:neocomplcache_enable_ignore_case = 1
  let g:neocomplcache_enable_smart_case = 1
  let g:neocomplcache_enable_auto_select = 1
  let g:neocomplcache_enable_fuzzy_completion = 1
  let g:neocomplcache_enable_camel_case_completion = 1
  let g:neocomplcache_enable_underbar_completion = 1
  let g:neocomplcache_fuzzy_completion_start_length = 1
  let g:neocomplcache_auto_completion_start_length = 1
  let g:neocomplcache_manual_completion_start_length = 1
  let g:neocomplcache_min_keyword_length = 1
  let g:neocomplcache_min_syntax_length = 1
  " complete with workds from any opened file
  let g:neocomplcache_same_filetype_lists = {}
  let g:neocomplcache_same_filetype_lists._ = '_'
endif

if IsLoad('signify')
  " this first setting decides in which order try to guess your current vcs
  " UPDATE it to reflect your preferences, it will speed up opening files
  let g:signify_vcs_list = [ 'git', 'hg' ]
  " nicer colors
  highlight DiffAdd           cterm=bold ctermbg=none ctermfg=119
  highlight DiffDelete        cterm=bold ctermbg=none ctermfg=167
  highlight DiffChange        cterm=bold ctermbg=none ctermfg=227
  highlight SignifySignAdd    cterm=bold ctermbg=237  ctermfg=119
  highlight SignifySignDelete cterm=bold ctermbg=237  ctermfg=167
  highlight SignifySignChange cterm=bold ctermbg=237  ctermfg=227
endif

if IsLoad('vim-json')
  let g:vim_json_syntax_conceal = 0
endif

if IsLoad('clang_complete')
  let g:clang_complete_auto = 1
  let g:clang_complete_copen = 1
  let g:clang_user_options='|| exit 0'
  if(g:system == 'mac')
    let g:clang_use_library = 1
    let g:clang_library_path = "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib"
  elseif(g:system == 'unix')
    let g:clang_use_library = 1
    let g:clang_library_path= "/usr/lib/clang"
  elseif (g:system == 'windows')
    let g:clang_use_library = 0
  elseif(g:system == 'cygwin')
    let g:clang_use_library = 1
    let g:clang_library_path= "/usr/bin"
  endif
endif

if IsLoad('YouCompleteMe')
  let g:ycm_key_list_select_completion = ['<c-n>', '<Down>']
  let g:ycm_key_list_previous_completion = ['<c-p>', '<Up>']
  let g:ycm_confirm_extra_conf = 0
  let g:ycm_autoclose_preview_window_after_completion=1
  map <leader>g  :YcmCompleter GoToDefinitionElseDeclaration<cr>
endif

if IsLoad('ultisnips')
  let g:UltiSnipsUsePythonVersion=2
  let g:UltiSnipsExpandTrigger="<tab>"
  let g:UltiSnipsJumpForwardTrigger="<c-j>"
  let g:UltiSnipsJumpBackwardTrigger="<c-k>"
  " If you want :UltiSnipsEdit to split your window.
  let g:UltiSnipsEditSplit="vertical"
endif

" ===============================================================================
" ctags
" ===============================================================================
" C++ tags: "!ctags -R --c++-kinds=+px --fields=+iaS --extra=+q ."
" map <C-]> :tselect <C-R>=expand("<cword>")<cr><cr>
" map <C-]> g<C-]>
" 添加特定的（已经生成tags）的函数库的tags
autocmd FileType cpp set tags+=~/.vim/cpp_src/tags

" ===============================================================================
" cscope
" ===============================================================================
if has("cscope")
  set csprg=cscope
  set cscopetag                       " Use both cscope and ctag
  set cscopeverbose                   " Show msg when cscope db added
  set cscopetagorder=0                " Use cscope for definition search first
endif

" auto load cscope.out
" function! LoadCscope()
"     let db = findfile("cscope.out", ".;")    "从当前目录往上找，直到找到 cscope.out 这个命令能到找到cscope.out的路径。
"     if (!empty(db))
"         let path = strpart(db, 0, match(db, "/cscope.out$"))
"         set nocsverb                                "suppress 'duplicate connection' error
"         exe "cs add " . db . " " . path
"         set csverb
"     endif
" endfunction
" autocmd BufRead,BufEnter *.cpp,*.hpp call LoadCscope()

"s: 查找C语言符号，即查找函数名、宏、枚举值等出现的地方
"g: 查找函数、宏、枚举等定义的位置，类似ctags所提供的功能
"d: 查找本函数调用的函数
"c: 查找调用本函数的函数
"t: 查找指定的字符串
"e: 查找egrep模式，相当于egrep功能，但查找速度快多了
"f: 查找并打开文件，类似vim的find功能
"i: 查找包含本文件的文
set cscopequickfix=s-,g-,c-,t-,e-,f-,i-,d-
nmap <C-@>s :cs find s <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>g :cs find g <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>c :cs find c <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>t :cs find t <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>e :cs find e <C-R>=expand("<cword>")<cr><cr>:copen<cr>
nmap <C-@>f :cs find f <C-R>=expand("<cfile>")<cr><cr>:copen<cr>
nmap <C-@>i :cs find i ^<C-R>=expand("<cfile>")<cr>$<cr>:copen<cr>
nmap <C-@>d :cs find d <C-R>=expand("<cword>")<cr><cr>:copen<cr>
