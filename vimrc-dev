" ============================================================================
" vimrc for develop
" Maintainer: ovsoil
"       hxyumail@gmail.com
"       http://ovsoil.com
" Create Date:
"       01/09/2015
" ============================================================================

" ============================================================================
" Platform
" ============================================================================
let g:system='unix'
let g:rcpath=$HOME
if (has('win32') || has('win95') || has('win64') || has('win16'))
  let g:system='windows'
  if has('nvim')
    let g:rcpath=$LOCALAPPDATA.'\nvim'
  endif
elseif (has('unix'))
  if has('nvim')
    let g:rcpath=$HOME.'/.local/share/nvim'
  endif
  if ( system('uname') =~ 'Darwin')
    let g:system='mac'
  endif
endif


" ============================================================================
" Vim-plug initialization
" ============================================================================
let vim_plug_just_installed = 0
if has('nvim')
  if g:system=='windows'
    let vim_plug = fnameescape(g:rcpath.'\site\autoload\plug.vim')
  else
    let vim_plug = fnameescape(g:rcpath.'/site/autoload/plug.vim')
  endif
else
  if g:system=='windows'
    let vim_plug = fnameescape(g:rcpath.'\vimfiles\autoload\plug.vim')
  else
    let vim_plug = fnameescape(g:rcpath.'/.vim/autoload/plug.vim')
  endif
endif
let vim_plug_path = fnamemodify(vim_plug, ":p:h")

if !filereadable(vim_plug)
  echo "Installing vim-plug ..."
  echo ""
  silent execute '!mkdir '.vim_plug_path
  silent execute '!curl -fLo '.vim_plug.' --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  let vim_plug_just_installed = 1
endif
" silent !mkdir -p ~/.vim/bin
" silent !curl -fLo ~/.vim/bin/markdown2ctags.py --create-dirs https://raw.githubusercontent.com/tamlok/vimconf/master/markdown2ctags.py

" manually load vim-plug the first time
if vim_plug_just_installed
  :execute 'source '.fnameescape(vim_plug)
endif

" ============================================================================
" Active plugins
" ============================================================================
call plug#begin('~/.vim/plugged')

" Plugins from github repos:
" Base
Plug 'tomtom/tlib_vim'                          " This library provides some utility functions
Plug 'vim-scripts/auto_mkdir'                   " auto_mkdir
Plug 'scrooloose/nerdtree'                      " Better file browser
Plug 'Valloric/ListToggle'                      " ListToggle: toggle quickfix and location-list
Plug 'ctrlpvim/ctrlp.vim'                       " Code and files fuzzy finder
Plug 'fisadev/vim-ctrlp-cmdpalette'             " Extension to ctrlp, for fuzzy command finder
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'easymotion/vim-easymotion'
Plug 'vim-scripts/IndexedSearch'                            " Search results counter
Plug 'mhinz/vim-startify'
if executable('ack')
  " Plug 'mileszs/ack.vim'                      " Ack code search (requires ack)
endif

" Enhancement
" Plug 'hecal3/vim-leader-guide'
if has('nvim') && has('python3')
  Plug 'Shougo/denite.nvim'
endif
Plug 'rosenfeld/conque-term'            " Consoles as buffers
Plug 'terryma/vim-multiple-cursors'     " Sublime Text style multiple selections for Vim
Plug 'tpope/vim-surround'               " surround
Plug 'terryma/vim-expand-region'        " visually select increasingly larger regions
Plug 'Raimondi/delimitMate'             " auto-completion for quotes, parens, brackets
" Plug 'tpope/vim-repeat'
Plug 'godlygeek/tabular'                " aligning text
" Plug 'vitalk/vim-simple-todo'

" Write
" Plug 'junegunn/limelight.vim'
Plug 'junegunn/goyo.vim', { 'for': 'markdown' }

" User Interface
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'flazz/vim-colorschemes'
Plug 'tomasr/molokai'
Plug 'altercation/vim-colors-solarized'
Plug 'fisadev/fisa-vim-colorscheme'
Plug 'morhetz/gruvbox'
" Plug 'Wombat'                           " Gvim colorscheme

" Develop
Plug 'w0rp/ale'
Plug 'michaeljsmith/vim-indent-object'  " Indent text object
Plug 'majutsushi/tagbar'                " Class/module browser
Plug 'tpope/vim-fugitive', { 'on': [] }
command! Gstatus call LazyLoadFugitive('Gstatus')
command! Gdiff call LazyLoadFugitive('Gdiff')
command! Glog call LazyLoadFugitive('Glog')
command! Gblame call LazyLoadFugitive('Gblame')

function! LazyLoadFugitive(cmd)
  call plug#load('vim-fugitive')
  call fugitive#detect(expand('%:p'))
  exe a:cmd
endfunction
Plug 'airblade/vim-gitgutter'           " Git/mercurial/.. diff icons

" commenter
" Plug 'tpope/vim-commentary'             " comment
Plug 'scrooloose/nerdcommenter'         " Code commenter
Plug 'vim-scripts/DoxygenToolkit.vim'   " doxygen

" complete
if has('nvim')
  if has('python3')
    Plug 'Shougo/deoplete.nvim', { 'do': ':UpdateRemotePlugins' }
    Plug 'zchee/deoplete-go', { 'do': 'make'}
  else
    Plug 'Shougo/neocomplcache.vim'
  endif
else
  Plug 'Shougo/neocomplete.vim'
endif

Plug 'honza/vim-snippets'
Plug 'garbas/vim-snipmate'

" json
Plug 'elzr/vim-json'

" markdown
Plug 'plasticboy/vim-markdown'
Plug 'mzlogin/vim-markdown-toc'
Plug 'joker1007/vim-markdown-quote-syntax'
Plug 'iamcco/mathjax-support-for-mkdp'
Plug 'iamcco/markdown-preview.vim'

" c/c++

" python
Plug 'klen/python-mode'
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'fisadev/vim-isort'                " Automatically sort python imports
Plug 'tmhedberg/SimpylFold'
if has('python')
  Plug 'pignacio/vim-yapf-format'       " YAPF formatter for Python
endif
Plug 'tell-k/vim-autopep8'

" javascript
Plug 'pangloss/vim-javascript'
Plug 'kchmck/vim-coffee-script'

" typescript
Plug 'leafgarland/typescript-vim'

" solidity
Plug 'tomlion/vim-solidity'

" html
Plug 'vim-scripts/matchit.zip'          " XML/HTML tags navigation
Plug 'mattn/emmet-vim'

" vue
Plug 'posva/vim-vue'

" ruby on rail
Plug 'tpope/vim-rails'

" erlang
" Plug 'oscarh/vimerl'
Plug 'vim-erlang/vim-erlang-compiler'
Plug 'vim-erlang/vim-erlang-skeletons'
Plug 'vim-erlang/vim-erlang-runtime'
Plug 'vim-erlang/vim-erlang-omnicomplete'
Plug 'vim-erlang/vim-erlang-tags'
Plug 'aerosol/vim-compot'

" lisp
Plug 'kovisoft/slimv'

" golang
Plug 'fatih/vim-go', { 'do': ':GoUpdateBinaries' }

" ttcn
Plug 'mincore/vim-ttcn', { 'for': 'ttcn'}

if exists('g:nyaovim_version')
  Plug 'rhysd/nyaovim-markdown-preview'
endif

call plug#end()

" ============================================================================
" Install plugins the first time vim runs
" ============================================================================
if vim_plug_just_installed
  echo "Installing Bundles, please ignore key map error messages"
  :PlugInstall
endif

" General Vim settings and mappings
" ============================================================================
" General
" ============================================================================
set nocompatible                                   " no vi-compatible
filetype plugin indent on                          " allow plugins by file type (required for plugins!)

if(g:system=="windows")
  set fileformats=dos,unix,mac
else
  set fileformats=unix,dos,mac
  set encoding=utf8
endif

set wildignore+=*.o,*~,*.so,*.swp,*.zip,*.pyc      " Ignore compiled files
set wildignore+=*_build/*
if(g:system=="windows")
  set wildignore+=*\\.git\\*,*\\.hg\\*,*\\.svn\\*  " Windows ('noshellslash')
  set wildignore+=*\\tmp\\*,*.swp,*.zip,*.exe
else
  set wildignore+=*/.git/*,*/.hg/*,*/.svn/*        " Linux/MacOSX
  set wildignore+=*/tmp/*,*.so,*.swp,*.zip
endif
set fileencodings=ucs-bom,utf-8,chinese
set formatoptions+=m                              " 如遇Unicode值大于255的文本，不必等到空格再折行。
set formatoptions+=B                              " 合并两行中文时，不在中间加空格：
set ambiwidth=single
set nrformats=                                    " 无论前面是否加零，都把数字作为十进制处理(在使用<C-x>, <C-a>的时候)
set autoread                                      " Set to auto read when a file is changed from the outside

if !has('nvim')
  " backup, swap and undos storage
  set noswapfile
  set directory=~/.vim/dirs/tmp     " directory to place swap files in
  set backup                        " make backup files
  " set nobackup                      " default: off
  " set nowritebackup                 " default: on
  set backupdir=~/.vim/dirs/backups " where to put backup files
  set undofile                      " persistent undos - undo after you re-open the file
  set undodir=~/.vim/dirs/undos
  set viminfo+=n~/.vim/dirs/viminfo
  " create needed directories if they don't exist
  if !isdirectory(&backupdir)
    call mkdir(&backupdir, "p")
  endif
  if !isdirectory(&directory)
    call mkdir(&directory, "p")
  endif
  if !isdirectory(&undodir)
    call mkdir(&undodir, "p")
  endif
  set viminfo^=%                  " Remember info about open buffers on close
endif

" Return to last edit position when opening files
autocmd BufReadPost *
      \ if line("'\"") > 0 && line("'\"") <= line("$") |
      \   exe "normal! g`\"" |
      \ endif

" ============================================================================
" User Interface
" ============================================================================
set nu                          " show line numbers
set ruler                       " Always show current position
set scrolloff=7                 " when scrolling, 7 lines away from screen border
set hid                         " A buffer becomes hidden when it is abandoned
" status line
set laststatus=2
set statusline=%<%f\ %h%m%r%=%k[%{(&fenc==\"\")?&enc:&fenc}%{(&bomb?\",BOM\":\"\")}]\ %-14.(%l,%c%V%)\ %P
" autocompletion of files and commands behaves like shell
" (complete only the common part, list the options that match)
set wildmode=list:longest
" Comment this line to enable autocompletion preview window
" (displays documentation related to the selected completion option)
" Disabled by default because preview makes the window flicker
set completeopt-=preview

syntax on                       " syntax highlight on
set incsearch                   " incremental search
set hlsearch                    " highlighted search results
set backspace=eol,start,indent  " Configure backspace so it acts as it should act
set whichwrap+=<,>,h,l
set ignorecase                  " Ignore case when searching
set smartcase                   " When searching try to be smart about cases
set hlsearch                    " Highlight search results

set lazyredraw                  " Don't redraw while executing macros
set magic                       " For regular expressions turn magic on
set showmatch                   " Show matching brackets
set mat=2                       " tenths of a second to blink when matching brackets

set noerrorbells                " No annoying sound on errors
set novisualbell
set vb t_vb=
set lbr                         " Linebreak on 500 characters
set tm=500
set tw=500

set autoindent                  " Auto indent
set smartindent                 " Smart indent
set cindent                     " C indent
set wrap                        " Wrap lines
set cinoptions=g0

" use 256 colors when possible
if (&term =~? 'mlterm\|xterm\|xterm-256\|screen-256\|gnome-terminal\|rxvt-unicode-256color') || has('nvim')
  let &t_Co = 256
  colorscheme gruvbox
else
  colorscheme delek
endif
set background=dark

" Set extra options when running in GUI mode
if has('gui_running')
  colorscheme wombat
  " colorscheme gruvbox
  if has("mac") || has("macunix")
    set guifont=Monaco\ for\ Powerline:h13
  elseif has("win32") || has("win64")
    set guifont=Monaco\ for\ Powerline:h14:cANSI
    set renderoptions=type:directx,renmode:5
  endif
  " set guifont=Source_Code_Pro:h13
  set guioptions-=T   " no toobar
  set guioptions-=r   " no right scroolbar
  set guioptions-=L   " no left scrollbar except there is a vertically split windows
  set guitablabel=%M\ %t
  set showtabline=0   " no tabine
  set linespace=2
  set noimd
  set t_Co=256
  set lines=40
  set columns=160
endif

set smarttab                      " Be smart when using tabs
set expandtab                     " Use spaces instead of tabs
set tabstop=4                     " display spaces number as tab
set softtabstop=4
set shiftwidth=4                  " insert 1 tab == 4 spaces
set list
nmap <leader>l :set list!<cr>
" set listchars=tab:\|\ ,eol:$    " display tab with '|    ', display lineend
set listchars=tab:\|\             " display tab with '|    '
highlight BadWhitespace ctermbg=LightYellow guibg=Yellow
au BufNewFile,BufRead *.py,*.pyw,*.c,*.h,*.coffee match BadWhitespace /\s\+$/

" Specific filetype
au BufNewFile,BufRead *.spacemacs setf lisp
au BufNewFile,BufRead *.ttcn setf ttcn
" FileType Specific Changes
if has ( "autocmd" )
  autocmd FileType vim setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType html,xhtml,xml,css,htmldjango,yaml,vue setlocal ts=2 sts=2 sw=2 expandtab
  autocmd FileType javascript,json setlocal ts=2 sts=2 sw=2 expandtab
endif

" set cursorcolumn          " highlight current column
" set cursorline            " highlight current line

" 设置标记一列的背景颜色和数字一行颜色一致
hi! link SignColumn   LineNr
hi! link ShowMarksHLl DiffAdd
hi! link ShowMarksHLu DiffChange
" for error highlight，防止错误整行标红导致看不清
highlight clear SpellBad
highlight SpellBad term=standout ctermfg=1 term=underline cterm=underline
highlight clear SpellCap
highlight SpellCap term=underline cterm=underline
highlight clear SpellRare
highlight SpellRare term=underline cterm=underline
highlight clear SpellLocal
highlight SpellLocal term=underline cterm=underline

" auto save folding
au BufWinLeave *.* silent mkview
au BufWinLeave *.* silent! loadview
set foldenable                  " enable folding
" set foldcolumn=2                " add a fold column
set foldmethod=syntax
set foldlevel=20

" ============================================================================
" Mapping
" F1 - help; F2 - file(nerdtree); F3 - tag(tagbar); F4 - tasklist
" ============================================================================
let mapleader = "\<Space>"
let g:mapleader = "\<Space>"

function! HasHelp()
  " Save current window number to revert.
  let nwin = 1
  while 1
    let nbuf = winbufnr(nwin)
    " all window processed, there is no help buftype, return 0
    if nbuf == -1
      return 0
    endif
    " if there is help buftype, return 1
    if getbufvar(nbuf, '&buftype') ==# 'help'
      return 1
    else
      let nwin = nwin + 1
    endif
  endwhile
endfunction

function! ToggleHelp()
  if HasHelp()
    :helpclose
  else
    :help
  endif
endfunction

" save as sudo
ca w!! w !sudo tee "%"

nmap <silent><F1> :call ToggleHelp()<cr>
nmap <leader>hh :call ToggleHelp()<cr>
" nmap <leader>hk :Maps<CR>               " Toggle keymap window

" ---------------------------------------
" command line map
" ---------------------------------------
:cnoremap <C-A> <Home>
:cnoremap <C-F> <Right>
:cnoremap <C-B> <Left>
:cnoremap <Esc>b <S-Left>
:cnoremap <Esc>f <S-Right>

" ---------------------------------------
" map for terminal in neovim
" ---------------------------------------
if has('nvim')
  " Terminal go back to normal mode
  tnoremap <Esc> <C-\><C-n>
  " When switching to terminal windows it goes into insert mode automatically
  au BufEnter * if &buftype == 'terminal' | :startinsert | endif
endif

" ---------------------------------------
" files navigation
" ---------------------------------------
" Buffer
nmap <leader>bn :bnext<cr>
nmap <leader>bp :bprevious<cr>
nmap <Leader>b1 :1b<CR>
nmap <Leader>b2 :2b<CR>
nmap <Leader>b3 :3b<CR>
nmap <Leader>b4 :4b<CR>
nmap <Leader>b5 :5b<CR>
nmap <Leader>b6 :6b<CR>
nmap <Leader>b7 :7b<CR>
nmap <Leader>b8 :8b<CR>
nmap <Leader>b9 :9b<CR>
nmap <Leader>b0 :10b<CR>
nmap <leader>bd :bdelete<cr>
nmap <leader>ba :1,1000 bd!<cr>
nmap <leader>b<tab> :b#<cr>
" Ngb to jump to buffer number N
let c = 1
while c <= 99
  execute "nnoremap " . c . "gb :" . c . "b\<CR>"
  let c += 1
endwhile
" switch CWD to the directory of the open buffer
nmap <leader>cd :cd %:p:h<cr>:pwd<cr>
" Specify the behavior when switching between buffers
try
  set switchbuf=useopen,usetab        " newtab
  set stal=2
catch
endtry

" Tab
" I rarely use tab :)

" ---------------------------------------
" windows Moving
" ---------------------------------------
map j gj
map k gk
nmap H ^
nmap L $
nmap <leader>wj <C-W>j
nmap <leader>wk <C-W>k
nmap <leader>wh <C-W>h
nmap <leader>wl <C-W>l
nmap <leader>ws :split<CR>
nmap <leader>wv :vs<CR>
nmap <leader>wc :close<CR>
if (g:system=="mac")
  nmap <D-j> <M-j>
  nmap <D-k> <M-k>
  vmap <D-j> <M-j>
  vmap <D-k> <M-k>
endif

" ---------------------------------------
" folding
" ---------------------------------------
nnoremap zO zCzO
nnoremap ,z zMzv

" ---------------------------------------
" Edit
" ---------------------------------------
" set pastetoggle=<leader>pt                      " Toggle paste mode (disable it for insert space issue)
nmap <leader>yy "+yy
nmap <leader>dd "+d
vmap <leader>dd "+d
nmap <leader>yy "+y
vmap <leader>yy "+y
nmap <leader>pp "+p
vmap <leader>pp "+p
nmap <leader>pP "+P
vmap <leader>pP "+P
map <leader>p "0p

noremap ty "+y
noremap tY "+Y  // copy a whole line to the clipboard
noremap tp "+p  // put the text from clipboard after the cursor
noremap tP "+P  // put the text from clipboard before the cursor

au InsertLeave * set nopaste                    " Disbale paste mode when leaving insert mode
nmap <leader>= <Esc>:%!python -m json.tool<cr>
" if (executable('pbcopy') || executable('xclip') || executable('xsel')) && has('clipboard')
"   set clipboard=unnamed
" endif

" Delete the blank space or Windows ^M at trail of line
func! DeleteTrailingWS()
  exe "normal mz"
  %s/\s\+$//ge
  exe "normal `z"
endfunc
nmap <leader>db :call DeleteTrailingWS()<cr>
nmap <leader>dm mmHmt:%s/<C-V><cr>//ge<cr>'tzt'm
autocmd BufWrite *.py :call DeleteTrailingWS()
autocmd BufWrite *.coffee :call DeleteTrailingWS()

" insert some usefull text
imap <silent> <C-D><C-D> <C-R>=strftime("%e %b %Y")<cr>
imap <silent> <C-T><C-T> <C-R>=strftime("%l:%M %p")<cr>
imap <silent> <C-C><C-C> <C-R>=string(eval(input("Calculate: ")))<cr>

" get selected text
func! s:get_visual_selection()
  " Why is this not a built-in Vim script function?!
  let [lnum1, col1] = getpos("'<")[1:2]
  let [lnum2, col2] = getpos("'>")[1:2]
  let lines = getline(lnum1, lnum2)
  let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
  let lines[0] = lines[0][col1 - 1:]
  return join(lines, "\n")
endfunc

" Replace the selected text which is path of an image with URL in QiuNiu Cloudu
" Upload the image to QiuNiu Cloud
function! ReplaceWithQiuniuURL()
  " yank current visual selection to reg x
  normal gv"xy
  " get basename of the image
  let basename = fnamemodify(@x, ":t")
  " upload image to 'blog' bucket of qiniu cloud
  exe printf("!qshell fput blog %s %s", basename, @x)
  " put new string value in reg x
  let @x = printf("![Alt](http://op9wke666.bkt.clouddn.com/%s)", basename)
  " re-select area and delete
  normal gvd
  " paste new string value back in
  normal "xp
endfunction
vnoremap <leader>ii :call ReplaceWithQiuniuURL()<cr>

" ---------------------------------------
" search, vimgrep
" ---------------------------------------
if executable('ag')             " The Silver Searcher
  set grepprg=ag\ --nogroup\ --nocolor
  let g:ctrlp_user_command = 'ag %s -i --nocolor --nogroup --ignore .git --ignore .DS_Store --ignore node_modules --ignore "**/*.pyc" --hidden -g ""'
  " ag is fast enough that CtrlP doesn't need to cache
  " let g:ctrlp_use_caching = 0
else
  set grepprg=grep\ -nrI\ --exclude-dir={CVS,'.bzr','.git','.hg','.svn'}
  if(g:system=="windows")
    let g:ctrlp_user_command = 'dir %s /-n /b /s /a-d'  " Windows
  else
    " MacOSX/Linux
    let g:ctrlp_user_command = [
          \ '.git', 'cd %s && git ls-files . -co --exclude-standard',
          \ 'find %s -type f'
          \ ]
  endif
endif

nnoremap <leader><cr> :nohl<cr>
" Search for selected text.
" vnoremap // y/<C-R>"<cr>     " use following script instead
" http://vim.wikia.com/wiki/VimTip171
let s:save_cpo = &cpo | set cpo&vim
if !exists('g:VeryLiteral')
  let g:VeryLiteral = 0
endif
function! s:VSetSearch(cmd)
  let old_reg = getreg('"')
  let old_regtype = getregtype('"')
  normal! gvy
  if @@ =~? '^[0-9a-z,_]*$' || @@ =~? '^[0-9a-z ,_]*$' && g:VeryLiteral
    let @/ = @@
  else
    let pat = escape(@@, a:cmd.'\')
    if g:VeryLiteral
      let pat = substitute(pat, '\n', '\\n', 'g')
    else
      let pat = substitute(pat, '^\_s\+', '\\s\\+', '')
      let pat = substitute(pat, '\_s\+$', '\\s\\*', '')
      let pat = substitute(pat, '\_s\+', '\\_s\\+', 'g')
    endif
    let @/ = '\V'.pat
  endif
  normal! gV
  call setreg('"', old_reg, old_regtype)
endfunction
vnoremap <silent> * :<C-U>call <SID>VSetSearch('/')<cr>/<C-R>/<cr>
vnoremap <silent> # :<C-U>call <SID>VSetSearch('?')<cr>?<C-R>/<cr>
vmap <kMultiply> *
nmap <silent> <Plug>VLToggle :let g:VeryLiteral = !g:VeryLiteral
      \\| echo "VeryLiteral " . (g:VeryLiteral ? "On" : "Off")<cr>
if !hasmapto("<Plug>VLToggle")
  nmap <unique> <Leader>vl <Plug>VLToggle
endif
let &cpo = s:save_cpo | unlet s:save_cpo

" highlight but not search the word at cursor
nnoremap <leader>h :let @/='\<<C-R>=expand("<cword>")<cr>\>'<cr>:set hls<cr>
" highlight but not search the selected text
vnoremap <leader>h :<C-U>call <SID>VSetSearch('/')<cr>/<C-R>/<cr>N

" replace selected text
vnoremap <leader>sr ""y:%s/<C-R>=escape(@", '/\')<cr>//gc<left><Left><Left>
vnoremap <leader>sR ""y:%s/<C-R>=escape(@", '/\')<cr>//g<Left><Left>
nnoremap <leader>sr :%s/<C-R><C-W>//gc"<left><left><left><left>
nnoremap <leader>sr :%s/<C-R><C-W>//g"<left><left><left>

" grep the word at cursor in current dir
nnoremap <leader>sw :grep! "\b<C-R><C-W>\b"<cr>:cw<cr>
vnoremap <leader>sw y:grep! '<C-R>"' .<cr>:cw<cr>

command! -nargs=+ -complete=file -bar Search silent! grep! <args>|cwindow|redraw!
nnoremap <leader>ss :Search<Space>''<left>

vnoremap <silent> y y`]
vnoremap <silent> p p`]
nnoremap <silent> p p`]

" ============================================================================
" Plugins settings and mappings
" ============================================================================
function! IsLoad(pluginname)
  if &runtimepath =~ a:pluginname
    return 1
  else
    return 0
  endif
endfunction

if IsLoad('nerdtree')
  nmap <silent><F2> :NERDTreeToggle<cr><cr>
  nmap <leader>ft :NERDTreeToggle<cr><cr>
  let g:NERDTree_title="NERDTree"
  let NERDTreeShowBookmarks=1         "allways show bookmarks
  let NERDTreeChDirMode=2             "auto set pwd when open bookmarks
  let NERDTreeIgnore=['node_modules', 'bower_components', '__pycache__', '\.pyc$', '\.pyo$', '\~$', '\.beam$']     "ignore files in NERDTree

  " open a NERDTree automatically when vim starts up if no files were specified
  " autocmd StdinReadPre * let s:std_in=1
  " autocmd VimEnter * if argc() == 0 && !exists("s:std_in") | NERDTree | endif

  " open NERDTree automatically when vim starts up on opening a directory
  autocmd StdinReadPre * let s:std_in=1
  autocmd VimEnter * if argc() == 1 && isdirectory(argv()[0]) && !exists("s:std_in") | exe 'NERDTree' argv()[0] | wincmd p | ene | endif

  " close vim if the only window left open is a NERDTree
  autocmd bufenter * if (winnr("$") == 1 && exists("b:NERDTree") && b:NERDTree.isTabTree()) | q | endif

  if !nerdtree#runningWindows()
    let g:NERDTreeDirArrowExpandable = '▸'
    let g:NERDTreeDirArrowCollapsible = '▾'
  else
    let g:NERDTreeDirArrowExpandable = '+'
    let g:NERDTreeDirArrowCollapsible = '~'
  endif
endif

if IsLoad('vim-leader-guide')
  " Define prefix dictionary
  let g:lmap =  {}

  " Second level dictionaries:
  " 'name' is a special field. It will define the name of the group.
  " leader-f is the "File Menu" group.
  let g:lmap.f = { 'name' : 'File Menu' }
  let g:lmap.b = { 'name' : 'Buffer Menu' }
  let g:lmap.w = { 'name' : 'Window Menu'}
  let g:lmap.s = { 'name' : 'Search Menu' }
  let g:lmap.t = { 'name' : 'Toggle Menu' }
  let g:lmap.d = { 'name' : 'Delete Menu'}
  " let g:lmap.o = { 'name' : 'Open Stuff' }

  " Provide commands and descriptions for existing mappings
  let g:lmap.f.d = ['e $MYVIMRC', 'Open vimrc']
  let g:lmap.f.s = ['so %', 'Source current file']
  let g:lmap.f.w = ['w', 'Save current file']
  let g:lmap.f.b = ['', 'Find file in opened buffer']
  let g:lmap.f.r = ['', 'Find a recent file']
  let g:lmap.f.j = ['', 'Nagative in current directory']

  let g:lmap.b.n = ['', 'next buffer']
  let g:lmap.b.p = ['', 'previous buffer']
  let g:lmap.b.1 = ['', 'open buffer 1']
  let g:lmap.b.2 = ['', 'open buffer 2']
  let g:lmap.b.3 = ['', 'open buffer 3']
  let g:lmap.b.4 = ['', 'open buffer 4']
  let g:lmap.b.5 = ['', 'open buffer 5']
  let g:lmap.b.6 = ['', 'open buffer 6']
  let g:lmap.b.7 = ['', 'open buffer 7']
  let g:lmap.b.8 = ['', 'open buffer 8']
  let g:lmap.b.9 = ['', 'open buffer 9']
  let g:lmap.b.0 = ['', 'open buffer 10']
  let g:lmap.b.d = ['', 'close current buffer']
  let g:lmap.b.a = ['', 'close all buffers']

  let g:lmap.w.j = ['', 'move to below window']
  let g:lmap.w.k = ['', 'move to above window']
  let g:lmap.w.h = ['', 'move to left window']
  let g:lmap.w.l = ['', 'move to right window']
  let g:lmap.w.s = ['', 'horizontal split']
  let g:lmap.w.v = ['', 'vertical split']
  let g:lmap.w.c = ['', 'close current windows']

  let g:lmap.s.s = ['', 'grep in pwd']
  let g:lmap.s.w = ['', 'grep cursor word in pwd']
  let g:lmap.s.t = ['', 'search cursor tag in current file']
  let g:lmap.s.T = ['', 'search cursor tag in pwd']
  let g:lmap.s.l = ['', 'search line in current file']
  let g:lmap.s.c = ['', 'search command']
  let g:lmap.s.r = ['', 'search and replace']

  " nmap <silent> <leader>oo  :copen<CR>
  " let g:lmap.o.o = ['copen', 'Open quickfix']

  " nmap <silent> <leader>ol  :lopen<CR>
  " let g:lmap.o.l = ['lopen', 'Open locationlist']


  " Create new menus not based on existing mappings:
  let g:lmap.g = {
        \'name' : 'Git Menu',
        \'s' : ['Gstatus', 'Git Status'],
        \'p' : ['Gpull',   'Git Pull'],
        \'u' : ['Gpush',   'Git Push'],
        \'c' : ['Gcommit', 'Git Commit'],
        \'w' : ['Gwrite',  'Git Write'],
        \}

  " If you use NERDCommenter:
  let g:lmap.c = { 'name' : 'Comments' }
  " Define some descriptions
  let g:lmap.c.c = ['call feedkeys("\<Plug>NERDCommenterComment")','Comment']
  let g:lmap.c['T'] = ['call feedkeys("\<Plug>NERDCommenterToggle")','Toggle']
  " The Descriptions for other mappings defined by NerdCommenter, will default
  " to their respective commands.
  call leaderGuide#register_prefix_descriptions("<Space>", "g:lmap")
  nnoremap <silent> <leader> :<c-u>LeaderGuide '<Space>'<CR>
  vnoremap <silent> <leader> :<c-u>LeaderGuideVisual '<Space>'<CR

  nnoremap <localleader> :<c-u>LeaderGuide  ','<CR>
  vnoremap <localleader> :<c-u>LeaderGuideVisual  ','<CR>
  " This variant won't habe any group names.

  " Group names can be defined by filetype. Add the following lines:
  let g:llmap = {}
  autocmd FileType tex let g:llmap.l = { 'name' : 'vimtex' }
  call leaderGuide#register_prefix_descriptions(",", "g:llmap")
  " to name the <localleader>-n group vimtex in tex files.
endif

if IsLoad('denite.nvim')
  call denite#custom#map(
        \ 'insert',
        \ '<C-j>',
        \ '<denite:move_to_next_line>',
        \ 'noremap'
        \)

  call denite#custom#map(
        \ 'insert',
        \ '<C-k>',
        \ '<denite:move_to_previous_line>',
        \ 'noremap'
        \)
endif

if IsLoad('tagbar')
  nmap <silent><F3> :TagbarToggle<cr>
  let g:tagbar_ctags_bin = 'ctags'
  let g:tagbar_width     = 30
  let g:tagbar_autofocus = 1      " autofocus on tagbar open
  let g:tagbar_left = 0
  " let g:tagbar_map_togglefold = ['t', 'za']
  " let g:tagbar_map_closefold = ['x', 'zc']
  " let g:tagbar_map_zoomwin = 'm'
  " let g:tagbar_map_jump = 'o'
  "autocmd BufReadPost *.cpp,*.c,*.h,*.hpp,*.cc,*.cxx call tagbar#autoopen()

  "" Add support for markdown files in tagbar.
  " let g:tagbar_type_markdown = {
  "       \ 'ctagstype': 'markdown',
  "       \ 'ctagsbin' : '~/.vim/bin/markdown2ctags.py',
  "       \ 'ctagsargs' : '-f - --sort=yes',
  "       \ 'kinds' : [
  "       \ 's:sections',
  "       \ 'i:images'
  "       \ ],
  "       \ 'sro' : '|',
  "       \ 'kind2scope' : {
  "       \ 's' : 'section',
  "       \ },
  "       \ 'sort': 0,
  "       \ }

  let g:tagbar_type_solidity = {
    \ 'ctagstype': 'solidity',
    \ 'kinds' : [
        \ 'c:contracts',
        \ 'e:events',
        \ 'f:functions',
        \ 'm:mappings',
        \ 'v:varialbes',
    \ ]
    \ }

endif

if IsLoad('fixedtasklist')
  map <F4> :TaskList<cr>                " show pending tasks list
  map <leader>lt :TaskList<cr>          " show pending tasks list
endif

if IsLoad('vim-simple-todo')
  let g:simple_todo_map_keys = 0        " Disable default key bindings
  nmap ,i <Plug>(simple-todo-new)
  imap ,i <Plug>(simple-todo-new)

  let g:simple_todo_tick_symbol = 'y'
endif

if IsLoad('ctrlp')
  " file finder mapping, avoid open file in nerdtree window
  nmap <silent> <expr> <Leader>ff (expand('%') =~ 'NERD_tree' ? "\<c-w>\<c-w>" : '').":CtrlP\<cr>"
  nmap <leader>fj :e .<cr>
  nmap <leader>fr :CtrlPMRU<cr>
  nmap <leader>fb :CtrlPBuffer<cr>
  nmap <leader>bb :CtrlPBuffer<cr>
  nmap <leader>fe :CtrlP <c-r>=expand("%:p:h")<cr><cr>
  " tags (symbols) in current file finder mapping
  nmap ,g :CtrlPBufTag<cr>
  nmap <leader>st :CtrlPBufTag<cr>
  " tags (symbols) in all files finder mapping
  nmap ,G :CtrlPBufTagAll<cr>
  nmap <leader>sT :CtrlPBufTagAll<cr>
  " general code finder in all files mapping
  nmap ,f :CtrlPLine<cr>
  nmap <leader>sl :CtrlPLine<cr>
  " commands finder mapping
  nmap ,c :CtrlPCmdPalette<cr>
  nmap <leader>sc :CtrlPCmdPalette<cr>
  " to be able to call CtrlP with default search text
  function! CtrlPWithSearchText(search_text, ctrlp_command_end)
    execute ':CtrlP' . a:ctrlp_command_end
    call feedkeys(a:search_text)
  endfunction
  " same as previous mappings, but calling with current word as default text
  nmap ,wg :call CtrlPWithSearchText(expand('<cword>'), 'BufTag')<cr>
  nmap ,wG :call CtrlPWithSearchText(expand('<cword>'), 'BufTagAll')<cr>
  nmap ,wf :call CtrlPWithSearchText(expand('<cword>'), 'Line')<cr>
  nmap ,we :call CtrlPWithSearchText(expand('<cword>'), '')<cr>
  nmap ,pe :call CtrlPWithSearchText(expand('<cfile>'), '')<cr>
  nmap ,wc :call CtrlPWithSearchText(expand('<cword>'), 'CmdPalette')<cr>
  " let g:ctrlp_working_path_mode = 0             " don't change working directory
  let g:ctrlp_working_path_mode = 'ra'        " smart change working directory
  " ignore these files and folders on file finder
  let g:ctrlp_custom_ignore = {
        \ 'dir':  '\v[\/](\.git|\.hg|\.svn|node_modules)$',
        \ 'file': '\.(o|swp|beam|pyc|pyo|wav|mp3|ogg|blend)$\|\.(log|jpg|png|jpeg)$|__init__\.py',
        \ }

  let g:ctrlp_buftag_types = {'go': '--language-force=go --golang-types=ftv'}
  " let g:ctrlp_buftag_types = {
  "     \ 'go'         : '--language-force=go --golang-types=ftv',
  "     \ 'coffee'     : '--language-force=coffee --coffee-types=cmfvf',
  "     \ 'markdown'   : '--language-force=markdown --markdown-types=hik',
  "     \ 'objc'       : '--language-force=objc --objc-types=mpci',
  "     \ 'rc'         : '--language-force=rust --rust-types=fTm',
  "     \ 'clojure'    : '--langmap=Lisp:+.clj'
  "     \ }
endif

if IsLoad('ack')
  " simple recursive grep
  nmap ,r :Ack
  nmap ,wr :Ack <cword><cr>
endif

if IsLoad('vim-startify')
  " let g:startify_list_order = [
  "       \ ['   Recent Files:'],
  "       \ 'files',
  "       \ ['   Project:'],
  "       \ 'dir',
  "       \ ['   Sessions:'],
  "       \ 'sessions',
  "       \ ['   Bookmarks:'],
  "       \ 'bookmarks',
  "       \ ['   Commands:'],
  "       \ 'commands',
  "       \ ]
  nnoremap <silent><leader>bh :Startify<CR>
endif

if IsLoad('vid-gitgutter')
  let g:gitgutter_max_signs=2000
endif

if IsLoad('vim-easymotion')
  " Jump to line
  map <leader>jl <Plug>(easymotion-bd-jk)
  nmap <leader>jl <Plug>(easymotion-overwin-line)
  " Jump to word
  map  <leader>jw <Plug>(easymotion-bd-w)
  nmap <leader>jw <Plug>(easymotion-overwin-w)
endif

if IsLoad('molokai')
  let g:molokai_original=1
  let g:rehash256=1
endif

if IsLoad('vim-airline')
  if(g:system=="mac")
    let g:airline_powerline_fonts = 1
  endif
  let g:airline_theme = 'bubblegum'
  let g:airline#extensions#default#layout = [
        \ [ 'a', 'b', 'c' ],
        \ [ 'x', 'y', 'z', 'error', 'warning' ]
        \ ]
  let g:airline#extensions#tabline#enabled = 1
  let g:airline#extensions#tabline#left_sep = ' '
  let g:airline#extensions#tabline#left_alt_sep = '|'
  let g:airline#extensions#tabline#buffer_nr_show = 1
  let g:airline#extensions#tabline#buffer_nr_format = '%s:'
  let g:airline#extensions#tabline#fnamecollapse = 1          "collopsing parent dir
  let g:airline#extensions#tabline#fnametruncate = 10         "non-active buffer name specified length
  let g:airline#extensions#bufferline#enabled = 0
  let g:airline#extensions#whitespace#enabled = 0
endif

if IsLoad('vim-expand-region')
  vmap v <Plug>(expand_region_expand)
  vmap <C-v> <Plug>(expand_region_shrink)
endif

if IsLoad('delimitmate')
  let delimitMate_quotes = "\" ' `"
  au FileType python,vim let b:delimitMate_quotes = "' `"
  au FileType markdown let b:delimitMate_quotes = "\" '"
  au FileType lisp,clojure let b:delimitMate_quotes = "\" `"

endif

if IsLoad('ale')
  let g:ale_linters = {
        \   'javascript': ['eslint'],
        \   'erlang': ['erlc'],
        \   'python': ['flake8'],
        \}
  let g:ale_fixers = {
        \   '*': ['remove_trailing_lines', 'trim_whitespace'],
        \   'javascript': ['eslint'],
        \   'python': ['autopep8'],
        \}
  let g:ale_sign_column_always = 1
  let g:ale_sign_error = '>'
  let g:ale_sign_warning = '-'
  let g:ale_lint_on_save = 1
  let g:ale_lint_on_text_changed = 1
  let g:ale_lint_on_enter = 1
  " let g:ale_fix_on_save = 1
  " Map movement through errors without wrapping.
  nmap <silent> <C-k> <Plug>(ale_previous)
  nmap <silent> <C-j> <Plug>(ale_next)


  let g:ale_python_flake8_executable = '/usr/local/bin/flake8'
  let g:ale_python_flake8_args = '--ignore=E501'
endif


if IsLoad('syntastic')
  " show list of errors and warnings on the current file
  nmap <leader>le :Errors<cr>
  let g:syntastic_always_populate_loc_list = 0
  let g:syntastic_auto_loc_list = 0
  let g:syntastic_check_on_open = 1
  let g:syntastic_check_on_wq = 0
  " don't put icons on the sign column (it hides the vcs status icons of signify)
  let g:syntastic_enable_signs = 0

  " c++11 support
  let g:syntastic_cpp_compiler = 'clang++'
  let g:syntastic_cpp_compiler_options = '-std=c++11 -stdlib=libc++'

  " python support
  " let g:syntastic_python_python_exec = '/path/to/python3'    " if use python3
  " let g:syntastic_python_checkers = ['pylint']
  let g:syntastic_python_checkers= ['flake8']
  let g:syntastic_python_flake8_post_args='--ignore=E501,E128'

  " erlang support
  " let g:syntastic_erlc_include_path = 'ebin'

  " custom icons (enable them if you use a patched font, and enable the previous
  " setting)
  "let g:syntastic_error_symbol = '✗'
  "let g:syntastic_warning_symbol = '⚠'
  "let g:syntastic_style_error_symbol = '✗'
  "let g:syntastic_style_warning_symbol = '⚠'

  " whether to show balloons
  let g:syntastic_enable_balloons = 1
endif

if IsLoad('nerdcommenter')
  " Add spaces after comment delimiters by default
  let g:NERDSpaceDelims = 1
  " Use compact syntax for prettified multi-line comments
  let g:NERDCompactSexyComs = 1
  " Align line-wise comment delimiters flush left instead of following code indentation
  let g:NERDDefaultAlign = 'left'
  " Set a language to use its alternate delimiters by default
  let g:NERDAltDelims_java = 1
  " Add your own custom formats or override the defaults
  let g:NERDCustomDelimiters = { 'c': { 'left': '/**','right': '*/' } }
  " Allow commenting and inverting empty lines (useful when commenting a region)
  let g:NERDCommentEmptyLines = 1
  " Enable trimming of trailing whitespace when uncommenting
  let g:NERDTrimTrailingWhitespace = 1
endif

if IsLoad('python-mode')
  " don't use linter, we use syntastic for that
  let g:pymode_lint_on_write = 0
  let g:pymode_lint_signs = 0
  " don't fold python code on open
  let g:pymode_folding = 0
  " don't load rope by default. Change to 1 to use rope
  let g:pymode_rope = 0
  " open definitions on same window, and custom mappings for definitions and
  " occurrences
  " Override go-to.definition key shortcut to Ctrl-]
  let g:pymode_rope_goto_definition_bind = "<C-]>"
  " let g:pymode_rope_goto_definition_bind = ',d'
  let g:pymode_rope_goto_definition_cmd = 'e'
  " Override run current python file key shortcut to Ctrl-Shift-e
  let g:pymode_run_bind = "<C-S-e>"
  " Override view python doc key shortcut to Ctrl-Shift-d
  " let g:pymode_doc_bind = "<C-S-d>"
  nmap ,D :tab split<cr>:PymodePython rope.goto()<cr>
  nmap ,o :RopeFindOccurrences<cr>

  let g:pymode_virtualenv = 1
  " let g:pymode_virtualenv_path = $VIRTUAL_ENV
  let g:pymode_python = 'python3'
endif

if IsLoad("simpyfold")
  let g:SimpylFold_docstring_preview=1
endif

if IsLoad('neocomplcache')
    " Disable AutoComplPop.
  let g:acp_enableAtStartup = 0
  " Use neocomplcache.
  let g:neocomplcache_enable_at_startup = 1
  " Use smartcase.
  let g:neocomplcache_enable_smart_case = 1
  " Set minimum syntax keyword length.
  let g:neocomplcache_min_syntax_length = 3
  let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'

  " Enable heavy features.
  " Use camel case completion.
  "let g:neocomplcache_enable_camel_case_completion = 1
  " Use underbar completion.
  "let g:neocomplcache_enable_underbar_completion = 1

  " Define dictionary.
  let g:neocomplcache_dictionary_filetype_lists = {
      \ 'default' : '',
      \ 'vimshell' : $HOME.'/.vimshell_hist',
      \ 'scheme' : $HOME.'/.gosh_completions'
          \ }

  " Define keyword.
  if !exists('g:neocomplcache_keyword_patterns')
      let g:neocomplcache_keyword_patterns = {}
  endif
  let g:neocomplcache_keyword_patterns['default'] = '\h\w*'

  " Plugin key-mappings.
  inoremap <expr><C-g>     neocomplcache#undo_completion()
  inoremap <expr><C-l>     neocomplcache#complete_common_string()

  " Recommended key-mappings.
  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  function! s:my_cr_function()
    return neocomplcache#smart_close_popup() . "\<CR>"
    " For no inserting <CR> key.
    "return pumvisible() ? neocomplcache#close_popup() : "\<CR>"
  endfunction
  " <TAB>: completion.
  inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h> neocomplcache#smart_close_popup()."\<C-h>"
  inoremap <expr><BS> neocomplcache#smart_close_popup()."\<C-h>"
  inoremap <expr><C-y>  neocomplcache#close_popup()
  inoremap <expr><C-e>  neocomplcache#cancel_popup()
  " Close popup by <Space>.
  "inoremap <expr><Space> pumvisible() ? neocomplcache#close_popup() : "\<Space>"

  " For cursor moving in insert mode(Not recommended)
  "inoremap <expr><Left>  neocomplcache#close_popup() . "\<Left>"
  "inoremap <expr><Right> neocomplcache#close_popup() . "\<Right>"
  "inoremap <expr><Up>    neocomplcache#close_popup() . "\<Up>"
  "inoremap <expr><Down>  neocomplcache#close_popup() . "\<Down>"
  " Or set this.
  "let g:neocomplcache_enable_cursor_hold_i = 1
  " Or set this.
  "let g:neocomplcache_enable_insert_char_pre = 1

  " AutoComplPop like behavior.
  " let g:neocomplcache_enable_auto_select = 1

  " Shell like behavior(not recommended).
  "set completeopt+=longest
  "let g:neocomplcache_enable_auto_select = 1
  "let g:neocomplcache_disable_auto_complete = 1
  "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

  " Enable omni completion.
  autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

  " Enable heavy omni completion.
  if !exists('g:neocomplcache_force_omni_patterns')
    let g:neocomplcache_force_omni_patterns = {}
  endif
  let g:neocomplcache_force_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  let g:neocomplcache_force_omni_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  let g:neocomplcache_force_omni_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

  " For perlomni.vim setting.
  " https://github.com/c9s/perlomni.vim
  let g:neocomplcache_force_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
endif

if IsLoad('neocomplete')
  " Disable AutoComplPop.
  let g:acp_enableAtStartup = 0
  " Use neocomplete.
  let g:neocomplete#enable_at_startup = 1
  " Use smartcase.
  let g:neocomplete#enable_smart_case = 1
  " Set minimum syntax keyword length.
  let g:neocomplete#sources#syntax#min_keyword_length = 3

  " Define dictionary.
  let g:neocomplete#sources#dictionary#dictionaries = {
        \ 'default' : '',
        \ 'vimshell' : $HOME.'/.vimshell_hist',
        \ 'scheme' : $HOME.'/.gosh_completions'
        \ }

  " Define keyword.
  if !exists('g:neocomplete#keyword_patterns')
    let g:neocomplete#keyword_patterns = {}
  endif
  let g:neocomplete#keyword_patterns['default'] = '\h\w*'

  " Plugin key-mappings.
  inoremap <expr><C-g>     neocomplete#undo_completion()
  inoremap <expr><C-l>     neocomplete#complete_common_string()

  " Recommended key-mappings.
  " <CR>: close popup and save indent.
  inoremap <silent> <CR> <C-r>=<SID>my_cr_function()<CR>
  function! s:my_cr_function()
    return (pumvisible() ? "\<C-y>" : "" ) . "\<CR>"
    " For no inserting <CR> key.
    "return pumvisible() ? "\<C-y>" : "\<CR>"
  endfunction
  " <TAB>: completion.
  inoremap <expr><TAB>  pumvisible() ? "\<C-n>" : "\<TAB>"
  " <C-h>, <BS>: close popup and delete backword char.
  inoremap <expr><C-h> neocomplete#smart_close_popup()."\<C-h>"
  inoremap <expr><BS> neocomplete#smart_close_popup()."\<C-h>"
  " Close popup by <Space>.
  "inoremap <expr><Space> pumvisible() ? "\<C-y>" : "\<Space>"

  " AutoComplPop like behavior.
  " let g:neocomplete#enable_auto_select = 1

  " Shell like behavior(not recommended).
  "set completeopt+=longest
  "let g:neocomplete#enable_auto_select = 1
  "let g:neocomplete#disable_auto_complete = 1
  "inoremap <expr><TAB>  pumvisible() ? "\<Down>" : "\<C-x>\<C-u>"

  " Enable omni completion.
  autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
  autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
  autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
  autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
  autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

  " Enable heavy omni completion.
  if !exists('g:neocomplete#sources#omni#input_patterns')
    let g:neocomplete#sources#omni#input_patterns = {}
  endif
  "let g:neocomplete#sources#omni#input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
  "let g:neocomplete#sources#omni#input_patterns.c = '[^.[:digit:] *\t]\%(\.\|->\)'
  "let g:neocomplete#sources#omni#input_patterns.cpp = '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'

  " For perlomni.vim setting.
  " https://github.com/c9s/perlomni.vim
  let g:neocomplete#sources#omni#input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
endif

if IsLoad('deoplete')
  let g:deoplete#enable_at_startup = 1
endif

if IsLoad('signify')
  " this first setting decides in which order try to guess your current vcs
  " UPDATE it to reflect your preferences, it will speed up opening files
  let g:signify_vcs_list = [ 'git', 'hg' ]
  " nicer colors
  highlight DiffAdd           cterm=bold ctermbg=none ctermfg=119
  highlight DiffDelete        cterm=bold ctermbg=none ctermfg=167
  highlight DiffChange        cterm=bold ctermbg=none ctermfg=227
  highlight SignifySignAdd    cterm=bold ctermbg=237  ctermfg=119
  highlight SignifySignDelete cterm=bold ctermbg=237  ctermfg=167
  highlight SignifySignChange cterm=bold ctermbg=237  ctermfg=227
endif

if IsLoad('vim-go')
  " :execute 'GoInstallBinaries'
endif

if IsLoad('vim-json')
  let g:vim_json_syntax_conceal = 0
endif

if IsLoad('clang_complete')
  let g:clang_complete_auto = 1
  let g:clang_complete_copen = 1
  let g:clang_user_options='|| exit 0'
  if(g:system == 'mac')
    let g:clang_use_library = 1
    let g:clang_library_path = "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/lib"
  elseif(g:system == 'unix')
    let g:clang_use_library = 1
    let g:clang_library_path= "/usr/lib/clang"
  elseif (g:system == 'windows')
    let g:clang_use_library = 0
  endif
endif

if IsLoad('YouCompleteMe')
  let g:ycm_key_list_select_completion = ['<c-n>', '<Down>']
  let g:ycm_key_list_previous_completion = ['<c-p>', '<Up>']
  let g:ycm_confirm_extra_conf = 0
  let g:ycm_autoclose_preview_window_after_completion=1
  map <leader>g  :YcmCompleter GoToDefinitionElseDeclaration<cr>
endif

if IsLoad('ultisnips')
  let g:UltiSnipsUsePythonVersion=2
  let g:UltiSnipsExpandTrigger="<tab>"
  let g:UltiSnipsJumpForwardTrigger="<c-j>"
  let g:UltiSnipsJumpBackwardTrigger="<c-k>"
  " If you want :UltiSnipsEdit to split your window.
  let g:UltiSnipsEditSplit="vertical"
endif


" ===============================================================================
" ctags
" how to generate C++ tags: !ctags -R --c++-kinds=+px --fields=+iaS --extra=+q .
" ===============================================================================
map <C-]> :tselect <C-R>=expand("<cword>")<cr><cr>
map <C-]> g<C-]>

" add custom tags file
" autocmd FileType cpp set tags+=~/.vim/cpp_src/tags

" ===============================================================================
" cscope
" ===============================================================================
if has("cscope")
  set csprg=cscope
  set cscopetag                       " Use both cscope and ctag
  set cscopeverbose                   " Show msg when cscope db added
  set cscopetagorder=0                " Use cscope, not ctags for definition search first
endif

" auto load cscope.out
function! LoadCscope()
    let db = findfile("cscope.out", ".;")    " find cscope.out
    if (!empty(db))
        let path = strpart(db, 0, match(db, "/cscope.out$"))
        set nocsverb                         " suppress 'duplicate connection' error
        exe "cs add " . db . " " . path
        set csverb
    endif
endfunction
autocmd BufRead,BufEnter *.cpp,*.hpp,*.go, call LoadCscope()

set cscopequickfix=s-,g-,c-,t-,e-,f-,i-,d-
nmap <leader>gs :cs find s <C-R>=expand("<cword>")<cr><cr>:copen<cr>    " Find this C symbol
nmap <leader>gg :cs find g <C-R>=expand("<cword>")<cr><cr>:copen<cr>    " Find this definition
nmap <leader>gd :cs find d <C-R>=expand("<cword>")<cr><cr>:copen<cr>    " Find functions called by this function
nmap <leader>gc :cs find c <C-R>=expand("<cword>")<cr><cr>:copen<cr>    " Find functions calling this function
nmap <leader>gt :cs find t <C-R>=expand("<cword>")<cr><cr>:copen<cr>    " Find this text string
nmap <leader>ge :cs find e <C-R>=expand("<cword>")<cr><cr>:copen<cr>    " Find this egrep pattern
nmap <leader>gf :cs find f <C-R>=expand("<cfile>")<cr><cr>:copen<cr>    " Find this file
nmap <leader>gi :cs find i ^<C-R>=expand("<cfile>")<cr>$<cr>:copen<cr>  " Find files #including this file
nmap <leader>ga :cs find a <C-R>=expand("<cfile>")<cr><cr>:copen<cr>    " Find places where this symbol is assigned a value
